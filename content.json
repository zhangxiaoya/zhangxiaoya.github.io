[{"title":"有趣的问题","date":"2018-08-22T14:55:57.000Z","path":"2018/08/22/interest-interview-one/","text":"最近校招浪潮开始了，互联网公式开始扎堆面试，翻了翻Google Calendar，9月份和10月份没有一天是闲着，每天不是面试就是笔试，最夸张的是一个周六有6场，从东边的乐视到西二旗的百度，面试多了，收到offer的同时，另外比较有意思的是面试题。offer都是千篇一律，但是有趣的面试题很少。工作以后也帮着部门面试候选人，也在思考如何考察面试候选人真实的基础是不是扎实，而又不是那些枯燥、烂大街的、枯燥的问题，让面试过程变成一场与候选人愉快的交流“内功”的过程。 先聊一聊我接触到比较有“深度”的面试题。 C++中的析构函数是谁调用的？问： 析构函数是干嘛的？ 答： 释放类申请的空间，多是指类成员中指针所指的空间，另外，不排除其他的方式申请空间，并放在析构函数来显式析构。 问： 谁来调用析构函数？ 答： 。。。操作系统 问： 操作系统怎么调用？ 答： （思考几秒钟，被面试官打断） 问： 换个方式问这个问题，如果一个程序被使用Ctrl + C了，那么它申请的空间怎么办？ 答： 这个问题没有仔细做过实验，但是根据我的学习的理论和经验，以及编译原理的知识，一个程序被编译器编程二进制代码，每个变量的声明周期，什么时候该销毁，什么时候该调用析构函数，编译器是完全能确定的，编译器会在恰当的时间点对这些没有显示调用delete的对象，生成一些调用析构函数的指令，完成对象的析构，比如，在函数中对象，会在函数执行结束后，添加析构函数指令，完成析构，程序结束时，会对全局变量进行析构，这些添加的析构指令，其实就是编译器把代码编译成二进制可执行文件时，不是一一翻译，而是有思想的解释程序，该调用析构的地方，实际上是隐式析构函数调用，只不过编译器完成了这部分工作。使用了Ctrl+C后，线程直接停止，很多二进制指令没有执行，也就造成了很多内存还没有来得及释放，造成内存泄露，这些内存会由操作系统最终来回收，但是不确定是什么时间回收。 面试官：很好。 这个面试官看重基础，算法问题只写了一个Middle级别的，由于写的漂亮，没有一点Bug，考虑了特殊Case，代码问题过关，所以剩下的时间完全考察基础，从编译原理，到CUDA编程的底层，从线性代数到概率论。还有一个比较有意思的是，CUDA中的share memory与寄存器哪个快，慢的为什么慢？这如果没有做过CUDA程序优化，估计回答上来的可能很小，share memory会有冲突，寄存器没有，但是它们共享一块 Block 存储器。 这算是针对“内功”的一次小的交流，面试官觉得不错，我觉得这种交流很舒服。 二叉树的先序遍历、中序遍历、后续遍历，缺了哪一个不行？这个答案不唯一，我在GitHub上给出了结果，还有部分源代码。","tags":[{"name":"Interesting","slug":"Interesting","permalink":"http://yoursite.com/tags/Interesting/"}]},{"title":"SLAM 第三章学习笔记","date":"2018-08-18T20:07:53.000Z","path":"2018/08/19/TheThirdCh-md/","text":"回顾第三章学习笔记。 1 旋转矩阵1.1 点，向量，坐标基本概念，在讨论坐标的过程中，必须基于某一个坐标系。介绍了向量内积和向量外积的计算方式，向量的内积很容易理解，外积可以用来表示向量的旋转。 1.2 坐标系间的欧式变换与向量之间的旋转类似，坐标系之间也可以进行旋转运算，再添加平移操作，综合起来叫做坐标系间的变换操作。欧式变换，是同一个向量在不同的坐标系下的长度和夹角都不发生变化。 根据一个向量，在坐标系发生旋转变化的时候，坐标不会发生变化，推理出旋转矩阵R，旋转矩阵是正交矩阵，并且行列式为1，由此引出特殊正交群（SO）。通过添加平移向量，以及齐次变换，计算得到变换矩阵T。 2 实践Eigeneigen是一个矩阵运算库，可以很方便的进行矩阵运算。 3 旋转向量与欧拉角3.1 旋转向量旋转操作只有3个自由度，但是旋转矩阵需要9个量来表示，有变量冗余，同样，变换操作有6个自由度，但是变化矩阵需要16个量表示，也存在冗余。减少量的计算。 向量的外积可以表示两个向量的旋转向量。对于坐标系的旋转，可以用一个旋转轴和一个旋转角度表示，定义这样一个向量，方向与旋转轴一致，大小等于旋转角，这种向量乘坐旋转向量。用三个变量的旋转向量表示旋转变换，再添加三个变量的平移向量，就可以表示变换操作。正好是6个变量。旋转向量与旋转矩阵的变化是通过罗德里格斯公式计算。 3.2 欧拉角欧拉角是另外一种使用角度的方式表示旋转，即三个坐标轴的旋转，表示整个坐标系的旋转。最典型的是ZYX旋转，第一次Z轴旋转，表示偏航（yaw），第二次Y轴旋转，表示俯仰（pitch），第三次是X轴旋转，表示滚转（roll）。但是第二次旋转若是90度的话，会遇到万向锁问题，失去一个自由度。 欧拉角直观理解很方便，但是不会直接用来计算。 4 四元数4.1 四元数的定义采用旋转向量或者欧拉角表示旋转会存在奇异性问题，用3个变量表示三维空间存在这样的问题，那就用4个变量表示三维空间。四元数就是这个么个玩意儿，一个实部，3个虚部，紧凑并且没有奇异性。 关于四元数表示旋转的性质，有一大堆需要理解。 4.2 四元数的运算类似于复数的运算。 4.3 用四元数表示旋转四元数旋转运算的结果会是一个纯虚四元数，其中的三个虚部分别表示旋转后的坐标。 4.4 四元数到旋转矩阵的转换5 相似、放射、影射变换欧式变换是最简单的变换，保持了向量的尺度和角度都不变化，只是6个自由度的变换。相似变换比欧式变化多了一个自由度，对物体的尺度进行了放缩，有7个自由度。仿射变换只要有旋转矩阵是一个可逆矩阵，不必是正交矩阵，放射变换又被乘坐是正交变换，物体的形状发生了变换，但是保持平行，具有体积比。射影变换是最一般的变换，自然界投影到相机就是射影变换。 6 实践Eigen的Geometry模块Eigen中的几何模块介绍很详细，使用简单。","tags":[{"name":"SLAM","slug":"SLAM","permalink":"http://yoursite.com/tags/SLAM/"}]},{"title":"基于SVM的图像分类","date":"2017-02-08T16:31:52.000Z","path":"2017/02/09/use-svm-training/","text":"今天在星巴克呆了一天，复习了一下学习的内容，翻到了研一期间旁听人工智能的课程设计，第一个完全写的一个基于SVM的图像分类任务，记得当时我是实验室第一个独立完成课程设计的，其他小伙伴还是参考我的代码，现在工业界，已经被漫天的深度学习覆盖，难道忘记了曾经万能的SVM了吗？ 还是写一遍小文，整理一下笔记，万一有初学者想要参考一下呢，也督促自己熟悉曾经做过的工作。 当时还在CSDN上写过一篇文章，原因是用matlab配置libsvm总是配置不好（当时Win8.1是最新版的系统，libsvm还是最流行的svm工具包，当时是2013年），博客地址在http://blog.csdn.net/qust_waiwai/article/details/17189787 ，只是写了个草稿，没想到，却成了评论最多的文章。 那就先把这个草稿整理完。 Windows64位 MATLAB使用LibSVM在LibSVM的网站上下载压缩包，然后解压。会发现有一些文件夹还有一些代码文件，其中一个MATLAB的的文件夹，里面就是提供的matlab接口（这些都在根目录的README文件里面介绍了，还有其他接口的安装与使用说明）。 在MATLAB这个目录下也有一个README文件，这个文件详细的描述了如何使用LibSVM的MATLAB接口，其中介绍了64位系统提供了 预编译好的二进制可执行文件。 1234On Windows systems, pre-built binary files are already in the directory '..\\windows', so no need to conduct installation. Now we provide binary files only for 64bit MATLAB on Windows. If you would like to re-build the package, please rely on the following steps. 至于为什么编译不好，先不浪费时间在这上面了，应该是编译器版本的原因，现在Win10要比Win8.1稳定了，应该就没有这个问题了。 将根目录中的windows目录拷贝到MATLAB的安装目录中的toolboxs中，里面全是各种包，不用自己在维护一个文件夹了，然后在MATLAB中Set Path，把这Windows目录添加进去，在MATLAB中就可以使用了。 输入 svmtrain 测试一下，会输出基本的用法： 12345678910&gt;&gt; svmtrainUsage: model = svmtrain(training_label_vector, training_instance_matrix, 'libsvm_options');libsvm_options:-s svm_type : set type of SVM (default 0) 0 -- C-SVC (multi-class classification) 1 -- nu-SVC (multi-class classification) 2 -- one-class SVM 3 -- epsilon-SVR (regression) 4 -- nu-SVR (regression)-t kernel_type : set type of kernel function (default 2) 基于SVM的图像分类这是一个课程设计，给定数据，设计分类器，建议使用SVM和kmeans。 问题描述两类图像（一种是动物，也就是恐龙，另外一种是公共汽车）每种图像95张，总共190张图片，为了方便操作，已经使用sift工具包提取了sift特征描述子，设计了个分类器，可采用直接分割的方法用来训练和测试，也可用交叉验证法训练和测试。 基本思路每个图像都被提取了SIFT特征，每个SIFT特征向量的维度是固定的，128维，但是每个图片会有多个sift描述子，数量不固定。 参考Bag of Visual Word模型，先用KMeans将将所有的SIFT描述子分类，比如分为10类，那么统计每个图像sift描述子的直方图分布描述子，这个直方图分布描述子就是10维的，这个类似于词袋模型，计算出每个图像的描述特征，然后用SVM训练一个监督学习分类器。 问题的关键点是用词袋模型来描述每张图片。 代码实现用matlab 实现，下面是两个代码文件。Main文件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120%%#########################################################################% 名称：作业一% 时间：2013.12.01% 姓名：张亚南% 专业：生物医学工程% 学院：计算机学院%##########################################################################%%%利用Bag of visual Word模型，使用Kmeans聚类，形成字典%分类，采用监督学习方法，SVM，每种特征训练集于测试集的比例大约为2：1%%%清空工作空间，清屏clear all; clc;%%%文件夹'k_f'中存放恐龙图片的特征向量%存放每个恐龙图片特征的文件名file_name_k = dir('k_f');%获取特征文件的个数n_k = length(file_name_k);%初始化一个矩阵，存放恐龙图片的所有的特征d_k =zeros(1,128); %初始化一个矩阵，存放每个恐龙图片的特征的个数num = zeros(1,2);%按照文件名读这些特征及其个数，分别存放在矩阵d_k和矩阵中numfor i=3:n_k %组合文件名 name = strcat('./k_f/',file_name_k(i).name); %没个特征文件第一行为特征的维数个个数，跳过第一行，读取特征矩阵，并用d临时存储 d = textread(name,'','headerlines',1); %采用textread读取数据时，默认是以空格为间隔标志，没恶感特征向量都在结尾多了一个0 ，去除最后一维数据 d =d(:,1:128); %将所有恐龙图片的特征向量存储在一个矩阵d_k中 d_k = [d_k ; d]; %eval(['data_k_' num2str(i-2) '=d']); %从每个文件中读出每个图片特征的个数个维数 t = textread(['./k_f/' file_name_k(i).name],'',1); %将每个图片的特征和维数都存放在矩阵num中 num = [num;t];end%end of loop %获取此时矩阵num的维数，去除初始化时的第一行的无用数据[m,n] =size(num);num = num(2:m,:);%获取恐龙图片的特征的矩阵的维数，去除初始化时第一行的无用数据[m,n] = size(d_k);d_k = d_k(2:m,:);%%%文件夹'_f'中存放汽车图片的特征向量%存放每个汽车图片特征的文件名file_name_q = dir('q_f');%获取特征文件的个数n_q = length(file_name_q);%初始化一个矩阵，存放汽车图片的所有的特征d_q = zeros(1,128);%按照文件名读这些特征及其个数，分别存放在矩阵d_q和矩阵中numfor i=3:n_q %组合文件名 name = strcat('./q_f/',file_name_q(i).name); %没个特征文件第一行为特征的维数个个数，跳过第一行，读取特征矩阵，并用d临时存储 d = textread(name,'','headerlines',1); %采用textread读取数据时，默认是以空格为间隔标志，没恶感特征向量都在结尾多了一个0 ，去除最后一维数据 d =d(:,1:128); %将所有汽车图片的特征向量存储在一个矩阵d_q中 d_q = [d_q ; d]; %eval(['data_q_' num2str(i-2) '=d']); %从每个文件中读出每个图片特征的个数个维数 t = textread(['./q_f/' file_name_q(i).name],'',1); %将每个图片的特征和维数都存放在矩阵num中 num= [num;t];end%end of loop%获取汽车图片的特征的矩阵的维数，去除初始化时第一行的无用数据[m,n] = size(d_q);d_q = d_q(2:m,:);%将恐龙和汽车的特征向量放在一个矩阵d中d = [d_k;d_q];%%%使用matlab内置的K-均值函数将所有的特征聚类%idx = kmeans(d,10);%使用K-中心点将所有的特征的聚类idx = KMeans(d,10,2);%%%初始化一个矩阵，用来记录每个图片特征给文件的由字典中的词的个数组成的向量dema = zeros(190,10);%设定每个图片特征在总的特征矩阵中的标志last = 0;%两重循环，构建每个特征文件的向量，组成一个新的矩阵for i = 1:190 for j =1:num(i,1) dema(i,idx(j+last)) = dema(i,idx(j+last)) +1; end last = num(i,1);end%分别提取出训练数据和测试数据，比例是2：1train_data = dema(1:60,:);train_data = [train_data;dema(96:155,:)];test_data = dema(61:95,:);test_data= [test_data;dema(156:190,:)];%存储类别标志，对应训练数据和测试数据label_train = zeros(1,60);label_train = [label_train,ones(1,60)];label_train = label_train';label_test = zeros(1,35);label_test = [label_test,ones(1,35)];label_test = label_test';%%%使用svmtrain函数训练model = svmtrain(label_train,train_data);%用训练的数据预测待测试的数据[predice_label,accuracy,dec_values] = svmpredict(label_test,test_data,model);%end KMeans是参考了网络资源：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960function label = KMeans( data,K,mode)% -data % -K: number of clusters% -mode: % 1: use kmeans cluster algorithm in matlab% 2: k_medroid algorithm: use data points as k centersN_samples = 91024;N_features = 128;switch (mode) %call system function KMeans case 1 label = kmeans(data,K); %use kmedroid method case 2 for testcase = 1:10% do 10 times to get rid of the influence from Initial_center K_center = Initial_center(data,K); %select initial points randomly changed_label = N_samples; label = zeros(1,N_samples); iteration_times = 0; while changed_label~=0 cls_label = cell(1,K); for i = 1: N_samples for j = 1 : K D(j) = dis(data(i,:),K_center(j,:)); end [~,label(i)] = min(D); cls_label&#123;label(i)&#125; = [cls_label&#123;label(i)&#125; i]; end changed_label = 0; cls_center = zeros(K,N_features); for i = 1 : K cls_center(i,:) = mean(data(cls_label&#123;i&#125;,:)); D1 = []; for j = 1:size(cls_label&#123;i&#125;,2)%number of samples clsutered in i-th class D1(j) = dis(cls_center(i,:),data(cls_label&#123;i&#125;(j),:)); end [~,min_ind] = min(D1); if ~isequal(K_center(i,:),data(cls_label&#123;i&#125;(min_ind),:)) K_center(i,:) = data(cls_label&#123;i&#125;(min_ind),:); changed_label = changed_label+1; end end iteration_times = iteration_times+1; end endend function center = Initial_center(X,K) rnd_Idx = randperm(N_samples,K); center = X(rnd_Idx,:); end function res = dis(X1,X2) res = norm(X1-X2); endend","tags":[{"name":"MATLAB","slug":"MATLAB","permalink":"http://yoursite.com/tags/MATLAB/"},{"name":"SVM","slug":"SVM","permalink":"http://yoursite.com/tags/SVM/"},{"name":"Windows","slug":"Windows","permalink":"http://yoursite.com/tags/Windows/"},{"name":"图像分类","slug":"图像分类","permalink":"http://yoursite.com/tags/图像分类/"}]},{"title":"在Windows10上使用Visual Studio 2015 测试Caffe","date":"2017-02-07T15:44:39.000Z","path":"2017/02/07/test-caffe-windows/","text":"在Windows10 上完成了配置，还没来得及测试，在Ubuntu下完成测试非常简单，在Caffe的根目录中有一个data的文件夹，这里面又包含了三个文件夹，分别对应了三个数据来源： cifar10 — 数据集 ilsvrc12 mnist — 手写字体数据库 数据集下载每个目录下都有 一个shell的脚本文件，在Ubuntu下的terminal运行，自动下载数据。比如下载mnist数据集的脚本是get_mnist.sh，其中的脚本是：123456789101112131415#!/usr/bin/env sh# This scripts downloads the mnist data and unzips it.DIR=\"$( cd \"$(dirname \"$0\")\" ; pwd -P )\"cd \"$DIR\"echo \"Downloading...\"for fname in train-images-idx3-ubyte train-labels-idx1-ubyte t10k-images-idx3-ubyte t10k-labels-idx1-ubytedo if [ ! -e $fname ]; then wget --no-check-certificate http://yann.lecun.com/exdb/mnist/$&#123;fname&#125;.gz gunzip $&#123;fname&#125;.gz fidone 就是下载这四个文件，当然也可以在mnist的网站上直接下载。 这个数据还需要转换，但是在Windows上编译的数据格式转格式的工程一直没配置好，所以就先用别人转换好的吧。 在这里下载，这个数据文件不全，只有leveldb的，另外一种没有，不过这个一个也足够完成一次测试了。 在Caffe根目录下会有一个example的文件夹，里面是caffe提供的测试，网络结构还有运行的shell脚本都写好了，但是在Win下不能直接用。在Win10下，采用这种方式编译的 caffe，会在script目录下的build文件夹中，caffe可执行文件在这个目录下的tools目录下的Release中，也就是caffe.exe。 把example中的mnist复制一份，命名为mnist_win，然后将下载的数据放在这个目录下，有两个文件夹： mnist-test-leveldb mnist-train-leveldb 修改训练测试文件修改训练配置文件lenet_train_test.prototxt，将文件中的数据路径和backed都修改，需要注意的是文件路径中的斜杠问题，要用双斜杠，否则会仿作转义符，如下所示（一共有四个地方，注意文件名中的下划线与横杆，找不到文件就是因为文件名不对）：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168name: \"LeNet\"layer &#123; name: \"mnist\" type: \"Data\" top: \"data\" top: \"label\" include &#123; phase: TRAIN &#125; transform_param &#123; scale: 0.00390625 &#125; data_param &#123; source: \"D:\\\\Application\\\\CaffeNew\\\\caffe\\\\examples\\\\mnist\\\\mnist-train-leveldb\" batch_size: 64 backend: LEVELDB &#125;&#125;layer &#123; name: \"mnist\" type: \"Data\" top: \"data\" top: \"label\" include &#123; phase: TEST &#125; transform_param &#123; scale: 0.00390625 &#125; data_param &#123; source: \"D:\\\\Application\\\\CaffeNew\\\\caffe\\\\examples\\\\mnist\\\\mnist-test-leveldb\" batch_size: 100 backend: LEVELDB &#125;&#125;layer &#123; name: \"conv1\" type: \"Convolution\" bottom: \"data\" top: \"conv1\" param &#123; lr_mult: 1 &#125; param &#123; lr_mult: 2 &#125; convolution_param &#123; num_output: 20 kernel_size: 5 stride: 1 weight_filler &#123; type: \"xavier\" &#125; bias_filler &#123; type: \"constant\" &#125; &#125;&#125;layer &#123; name: \"pool1\" type: \"Pooling\" bottom: \"conv1\" top: \"pool1\" pooling_param &#123; pool: MAX kernel_size: 2 stride: 2 &#125;&#125;layer &#123; name: \"conv2\" type: \"Convolution\" bottom: \"pool1\" top: \"conv2\" param &#123; lr_mult: 1 &#125; param &#123; lr_mult: 2 &#125; convolution_param &#123; num_output: 50 kernel_size: 5 stride: 1 weight_filler &#123; type: \"xavier\" &#125; bias_filler &#123; type: \"constant\" &#125; &#125;&#125;layer &#123; name: \"pool2\" type: \"Pooling\" bottom: \"conv2\" top: \"pool2\" pooling_param &#123; pool: MAX kernel_size: 2 stride: 2 &#125;&#125;layer &#123; name: \"ip1\" type: \"InnerProduct\" bottom: \"pool2\" top: \"ip1\" param &#123; lr_mult: 1 &#125; param &#123; lr_mult: 2 &#125; inner_product_param &#123; num_output: 500 weight_filler &#123; type: \"xavier\" &#125; bias_filler &#123; type: \"constant\" &#125; &#125;&#125;layer &#123; name: \"relu1\" type: \"ReLU\" bottom: \"ip1\" top: \"ip1\"&#125;layer &#123; name: \"ip2\" type: \"InnerProduct\" bottom: \"ip1\" top: \"ip2\" param &#123; lr_mult: 1 &#125; param &#123; lr_mult: 2 &#125; inner_product_param &#123; num_output: 10 weight_filler &#123; type: \"xavier\" &#125; bias_filler &#123; type: \"constant\" &#125; &#125;&#125;layer &#123; name: \"accuracy\" type: \"Accuracy\" bottom: \"ip2\" bottom: \"label\" top: \"accuracy\" include &#123; phase: TEST &#125;&#125;layer &#123; name: \"loss\" type: \"SoftmaxWithLoss\" bottom: \"ip2\" bottom: \"label\" top: \"loss\"&#125; 修改网络配置参数修改参数配置文件lenet_solver.prototxt，这里面制定了训练测试文件的目录，还有其他参数，也是要注意路径中的斜杠问题，下面是我的配置文件。 12345678910111213141516171819202122232425# The train/test net protocol buffer definitionnet: \"D:\\\\Application\\\\CaffeNew\\\\caffe\\\\examples\\\\mnist\\\\lenet_train_test.prototxt\"# test_iter specifies how many forward passes the test should carry out.# In the case of MNIST, we have test batch size 100 and 100 test iterations,# covering the full 10,000 testing images.test_iter: 100# Carry out testing every 500 training iterations.test_interval: 500# The base learning rate, momentum and the weight decay of the network.base_lr: 0.01momentum: 0.9weight_decay: 0.0005# The learning rate policylr_policy: \"inv\"gamma: 0.0001power: 0.75# Display every 100 iterationsdisplay: 100# The maximum number of iterationsmax_iter: 10000# snapshot intermediate resultssnapshot: 5000snapshot_prefix: \"D:\\\\Application\\\\CaffeNew\\\\caffe\\\\examples\\\\mnist\\\\lenet\"# solver mode: CPU or GPUsolver_mode: GPU 运行一下然后就可以运行了，可以直接在命令行中写命令：1D:\\Application\\CaffeNew\\caffe\\scripts\\build\\tools\\Release\\caffe.exe train --solver=D:\\Application\\CaffeNew\\caffe\\examples\\mnist\\lenet_solver.prototxt 也可以写一个批处理文件放在当前目录，我写一个批处理文件run.bat，双击就可以运行了： 123D:\\Application\\CaffeNew\\caffe\\scripts\\build\\tools\\Release\\caffe.exe train --solver=D:\\Application\\CaffeNew\\caffe\\examples\\mnist\\lenet_solver.prototxt Pause 如果之前都配置的没错的话，这里应该没有问题，准确率0.9+。 参考http://blog.csdn.net/light169/article/details/53993893","tags":[{"name":"Caffe","slug":"Caffe","permalink":"http://yoursite.com/tags/Caffe/"},{"name":"VS2015","slug":"VS2015","permalink":"http://yoursite.com/tags/VS2015/"},{"name":"Windows","slug":"Windows","permalink":"http://yoursite.com/tags/Windows/"}]},{"title":"在Windows10上使用Visual Studio 2015 构建Caffe","date":"2017-02-04T15:48:57.000Z","path":"2017/02/04/Caffe-windows-vs2015/","text":"笔记本是双显卡，读研的时候成功的在Ubuntu下配置好了一次Caffe，并且完成了深度学习的实验，前不久因为一个小的问题，导致NVIDIA驱动出了问题，以后再也没有在Ubuntu下成功配置好Caffe，不浪费时间在双显卡配置上了，转移到Windows下，正好也方便整理笔记。 首先是我的安装过程中需要注意的问题，其实大部分问题都是阅读完整个文档都可以解决，但是通常不喜欢阅读英文文档，或者一眼带过，很容易丢掉一些细节，介绍完我的安装步骤和问题，我顺手翻译了一下官方的文档。 我的安装步骤1 Clone仓库，并修改当前路径到caffe目录，切换到Windows分支：123C:\\Projects&gt; git clone https://github.com/BVLC/caffe.gitC:\\Projects&gt; cd caffeC:\\Projects\\caffe&gt; git checkout windows 第一次尝试构建1C:\\Projects\\caffe&gt; scripts\\build_win.cmd CMake出错，我安装了两个CMake，一个是2.8，一个是3.7，前者是编译Qt用的，并且还在使用，不想删掉，在Win10的环境变量中支持排序，将CMake3.7排在前面，就解决了CMake版本的问题，其实这里完全可以删掉2.8，但是我想留着以后编译Qt4.X的时候使用。3 继续编译，Ninja找不到，我本机没有安装Ninja，但是在build_win.cmd批处理文件中默认是使用Ninja，把编译选项修改就可以了if NOT DEFINED WITH_NINJA set WITH_NINJA=04 继续编译，下载依赖项失败，手动打开Python下载依赖项的脚本，会看到下面的代码：12345678WIN_DEPENDENCIES_URLS = &#123; ('v120', '2.7'):(\"https://github.com/willyd/caffe-builder/releases/download/v1.0.1/libraries_v120_x64_py27_1.0.1.tar.bz2\", \"3f45fe3f27b27a7809f9de1bd85e56888b01dbe2\"), ('v140', '2.7'):(\"https://github.com/willyd/caffe-builder/releases/download/v1.0.1/libraries_v140_x64_py27_1.0.1.tar.bz2\", \"427faf33745cf8cd70c7d043c85db7dda7243122\"), ('v140', '3.5'):(\"https://github.com/willyd/caffe-builder/releases/download/v1.0.1/libraries_v140_x64_py35_1.0.1.tar.bz2\", \"1f55dac54aeab7ae3a1cda145ca272dea606bdf9\"),&#125; 对应不同的编译器版本和Python版本，选择一个合适的，我这里是140和3.5，手动下载依赖项，并拷贝到scripts\\build目录下，解压到当前文件夹，就会出现一个libraries的目录，这就是所有的依赖项（还有OpenCV都在里面），继续编译，如果编译器和Python的版本都是对的，那么就会编译成功，大约需要16分钟。 下面是翻译的文档，参考Caffe-Windows项目： Windows Caffe声明Caffe的Windows版本是一个实验性的、社区版，是由Guillaume Dumont (@willyd)这个人主持开发的，目前正在开发过程中。这是Caffe仓库的一个分支，分支名是Windows，这个分支就是提供一个在Windows上的Caffe框架。 预编译的二进制文件在appveyor 上的持续化集成CI环境编译构建生成的二进制文件也可以下载，根据不同的配置有如下几个版本。 Visual Studio 2015, CPU only, Python 3.5: Caffe Release Visual Studio 2015, CUDA 8.0, Python 3.5: Caffe Release Visual Studio 2015, CPU only, Python 2.7: Caffe Release, Caffe Debug Visual Studio 2015,CUDA 8.0, Python 2.7: Caffe Release Visual Studio 2013, CPU only, Python 2.7: Caffe Release, Caffe Debug 这些链接是关联的CI环境生成的文件，应该会发生变化，需要下载的请关注Caffe的Github Windows 配置Caffe需求 Visual studio 2013或者2015 CMake3.4或者更高版本（用于支持Visual Studio 和 Ninja） 依赖选项 Python用于支持pycaffe，选择Anaconda Python 2.7 or 3.5 x64 (or Miniconda)，直接安装Anaconda，过程简单 MATLAB用于支持Matcaffe CUDA 7.5或者8.0，8.0的话需要使用Visual Studio 2015 cnDNN v5 保证CMake和Python都已经添加到环境变量了，如果有多个CMake版本的话，保证CMake3.4或者更高版本的变量值排在低版本的前面，系统会找到第一个符合的版本，若是低版本的没有使用，可以去除低版本的环境变量，现在Windows10 支持调整环境变量顺序。 配置并且编译Caffe最快的方式在Windows上上手Caffe，只需要在Windows的命令行中执行下面的命令(假设C:\\Projects是我们创建的目录，用来编译Caffe)： 12345678:: 从GitHub上clone 仓库C:\\Projects&gt; git clone https://github.com/BVLC/caffe.git:: 跳转到目录中C:\\Projects&gt; cd caffe:: 切换到Windows分支（远程分支，在本地创建并关联到远程分支），C:\\Projects\\caffe&gt; git checkout windows:: Edit any of the options inside build_win.cmd to suit your needsC:\\Projects\\caffe&gt; scripts\\build_win.cmd 上面的代码Windows可以存储到支持的脚本文件，冒号表示注释，扩展名是.cmd，也可以直接在命令行中输入。 其中build_win.cmd也是一个脚本文件，这个脚本用来下载依赖项，创建Visual Studio工程文件（或者Ninja构建文件），并且构建发布的配置，默认情况下，所有需要的DLL都必须拷贝到用到他们的二进制文件旁边（如果可能的话，可以创建硬链接），如果期望禁用这个选项，需要修改这个脚本文件中关于CMake的配置选项，将-DCOPY_PREREQUISITES=0。预编译的二进制库文件，也提供了一个prependpath.bat批处理文件，这个批处理文件可以临时的修改环境变量，让需要的DLL都可以找到。 下面是一些比较复杂的在构建Caffe过程中一些步骤的描述： 安装Caffe的依赖项默认情况下，CMake会根据编译器版本和Python版本下载和解压预编译好的依赖项，会在build文件夹下创建一个叫作libraries 的目录，这个目录中包含了所有的需要的依赖项。你也可以这样做，根据在caffe-builder中的README自己手动的编译这些依赖项。 使用 cuDNN使用cuDNN最简单的方式是将cuDNN解压后的cuda目录中的内容拷贝到CUDA工具包的安装目录下，比如，如果是安装的CUDA8.0，然后下载cudnn-8.0-windows10-x64-v5.1.zip，那么应该将cuda目录中的文件拷贝到C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v8.0对应的目录下。另外，也可以定义一个CUDNN_ROOT的缓存变量用来只想解压后的cuDNN目录，比如，解压目录是C:/Projects/caffe/cudnn-8.0-windows10-x64-v5.1/cuda，那么，对应的build_win.cmd脚本文件中的CMake的配置就会变成下面样子（其实就是添加一个编译选项），1234567891011cmake -G\"!CMAKE_GENERATOR!\" ^ -DBLAS=Open ^ -DCMAKE_BUILD_TYPE:STRING=%CMAKE_CONFIG% ^ -DBUILD_SHARED_LIBS:BOOL=%CMAKE_BUILD_SHARED_LIBS% ^ -DBUILD_python:BOOL=%BUILD_PYTHON% ^ -DBUILD_python_layer:BOOL=%BUILD_PYTHON_LAYER% ^ -DBUILD_matlab:BOOL=%BUILD_MATLAB% ^ -DCPU_ONLY:BOOL=%CPU_ONLY% ^ -DCUDNN_ROOT=C:/Projects/caffe/cudnn-8.0-windows10-x64-v5.1/cuda ^ -C \"%cd%\\libraries\\caffe-builder-config.cmake\" ^ \"%~dp0\\..\" 另外一种方式是打开CMake的GUI工具，设置变量，然后点击Generate按钮 仅对CPU构建如果没有安装CUDA，那么Caffe默认是仅对CPU构建，但是如果已经安装了CUDA，但是还是想只对CPU构建，那么可以修改CMake的编译选项-DCPU_ONLY=1。 使用Python接口推荐使用Anaconda 或者Miniconda这两个Python发布版本（非常简单），为了能成功的编译除Python接口，需要安装下面的包：1conda install --yes numpy scipy matplotlib scikit-image pip six 你也将会需要使用protobuf Python包，这个包是与预编译的依赖项兼容的，这个包的安装命令是：1conda install --yes --channel willyd protobuf==3.1.0 如果已经安装了额Python，那么将会默认编译Python接口和Python层，如果你想禁用Python层和Python构建版本，那么需要分别修改CMake的编译选项：-DBUILD_python_layer=0和-DBUILD_python=0。使用Python接口的时候，需要添加C:\\Projects\\caffe\\python到环境变量，并把C:\\Projects\\caffe\\python\\caffe拷贝到site_packages目录下。 使用MATLAB接口根据前面的步骤，然后使用-DBUILD_matlab=ON的编译选项。改变当前路径到C:\\Projects\\caffe\\matlab，然后运行下面的命令，运行测试：1caffe.run_tests() 如果所有的测试都过了，可以测试是否所有的分类的demo都工作。首先，从目录C:\\Projects\\caffe中运行python scripts\\download_model_binary.py models\\bvlc_reference_caffenet从model zoo中下载预先训练好的caffemodel，然后改变当前路径到C:\\Projects\\caffe\\matlab\\demo，然后运行classification_demo。 使用Ninja产生器如果想更快的构建，可以选择使用Ninja产生器替换Visual Studio，为了能这样做，在构建脚本文件中修改选项set WITH_NINJA=1，通过conda命令，从GitHub上下载并且安装Ninja：12conda config --add channels conda-forgeconda install ninja --yes 当使用Ninja的时候，不会产生Visual Studio解决方案文件，Ninja是与make一个体系的，一个选择是使用Visual Studio Code并且使用CMake 扩展和C++扩展。 构建一个共享库CMake可以被用来构建一个共享库，不仅仅是默认的静态库，为了做到这一点，需要Follow前面的步骤，并且使用-DBUILD_SHARED_LIBS=ON编译选项。需要注意的是，一些测试（具体一些是solver相关的测试）会挂掉，原因是测试的执行文件和Caffe的库不共享在protobuf库中的静态对象。 已知的问题 GPUTimer 相关的测试总是挂掉，这个貌似是以为Unix与Windows的不同 构建共享库会挂掉测试 只有使用Ninja产生器，共享库构建才工作","tags":[{"name":"Caffe","slug":"Caffe","permalink":"http://yoursite.com/tags/Caffe/"},{"name":"VS2015","slug":"VS2015","permalink":"http://yoursite.com/tags/VS2015/"},{"name":"Windows","slug":"Windows","permalink":"http://yoursite.com/tags/Windows/"}]},{"title":"从双层感知机到BP神经网络的Delta规则","date":"2017-01-22T23:15:59.000Z","path":"2017/01/23/from-simple-perceptron-to-BP/","text":"@(人工智能学习) 这是研一学习一门课程的课程实践，总结在印象笔记，还做了一个小的学术报告，当时和另一位实验室小伙伴合作完成BP神经网络的推导以及部分应用，参考的是一本外文书籍（影印版）的部分章节，有我自己翻译的部分，也有自己的理解，整理在一起，放在自己的博客中方便师弟师妹学习。 问题的来源在这之前，通过两层网络结构了解一些概念！之前学习过两层网络的问题，是一种简单的直接映射网络，只有输入层和输出层，输入模式经过输入层与输出层映射，得到输出映射。但这样的网络没有隐含层，也就没有内部表达，对输出输出的要求也比较严格，必须满足某种条件的映射。虽然有各种限制，两层神经网络也有一定的应用，两层的网络结构通常来完成一些合理的规则化映射，比如与问题（&amp;），规则明显，通过输入输出之间overlap就可以确定。 输入模式：网络的输入向量； 输出模式：网络的输出向量； 输入层：输入向量对应的输入单元组成的单元集合； 输出层：输出向量对应的输出单元组成的单元集合； 单元：网络的每个节点。 这里的输入模式和输出模式是指的输入向量和输出向量，一个模式也就对应着一个向量，一个模式对也就是对应着对训练数据。 但是由于这种简单的输入输出的映射的限制，对于特定输入到输出的映射是没有能力满足的。特别是当输入输出的相似的结构提供的表达信息非常不同的时候，没有内部表达的神经网络是不能够提供我们需要的唯一映射。一个比较经典的例子是异或问题（XOR），这时候，overlap可能产生多个结果，因此对这样的问题，就需要内部编码，增强网络的映射。 Input Layer OutPut Layer 0 0 0 0 1 1 1 0 1 1 1 0 对于XOR问题，可以修改双层网络来变相求解，但是通用的方式还是添加内部表达。如下表，在输入层添加一个节点： Input Layer OutPut Layer 0 0 0 0 0 1 0 1 1 0 0 1 1 1 1 0 这都不是重点，重点是XOR问题，两层结构的网络是没办法解决的（除了上面这个添加输入层节点的方式），这就需要有新的网络结构，这样的新的网络有更强的映射能力，解决两层结构的网络不能解决的问题。 内部表达（internal representation）什么是内部表达？内部表达实际上是将输入层编码的一种表达，直观上理解是将输入层的输入模式映射的一组编码的网络结构（连接及权重），后面的叙述慢慢会体现这一点。1969年，Minsky 和 Papert 提供了一个某种条件详细的分析，这种条件存在于一个系统中，这个系统能够解决需要的映射。他们通过大量的案例和网络展示了这种这种条件可以解决问题（我们需要的映射）。另一方面，M&amp;P两人同时还指出，若在一个简单的类似于感知机隐藏单元，通过这个隐含单元，输入层的输入模式会被增强，输入模式总是在隐藏单元被重新编码（或者称作内部表达），在这些隐藏层单元中，它们之间的模式的相似性，支持从输入层到输出层的映射。这样的话，如果输入层到隐藏单元之间存在正确的链接，并且这个隐藏单元集合足够大，那么就能找到一个内部表达，使得这样的网络结构满足输入到输出的映射。这里的内部表达其实就是经过输入层到隐藏层之间的网络连接权重，输入模式被重新编码。这就是引入隐藏层的网络结构，如下图所示。 利用隐藏层解决XOR问题，在文中给出了一个说明，只需添加了只有一个节点的隐藏层。下图有说明： 这样的网络的存在，说明了隐藏层和内部表达的求解问题（映射）能力。M&amp; P指出这样一个问题：对于没有隐藏层的网络，存在一个非常简单的对所有问题的学习规则，这个规则可以保证解决所有的映射问题（没有隐藏层的网络），这个规则被称作是感知器收敛规则，也被人称作delta规则，但是在具有隐藏层的神经网络中，没有同样的能力的规则。对于这样的缺陷，有三个基本的反馈（不太理解这里什么意思）： 第一个原因是竞争学习，在竞争学习中，使用简单的非监督学习规则，以致于有用的隐藏层单元发展。尽管这些方法是有前景的，但是没有外部的力量保证隐藏层单元适用于我们需要的映射，而且这些映射已经成熟的。 第二个原因是简单的假设内部表达，虽然有一些先验的根据，看起来这是有根据的。这是在verb learning章节和互动激活单词认知模型的策略， 第三个原因是尝试开发一个学习过程，这个过程学习过程由能力学习一个内部表达，内部表达足够解决当前的任务。在玻尔兹曼机的章节中，有描述类似的过程。正如我们所看到的，这个过程包含随机单元的使用，需要使网络达到两个阶段对等的状态，这限制了网络的同步。当然，其他人也使用了随机单元。 在本章节内容，我们提出了一个可供选择的方式，这种方式采用确定的单元（数），并且仅涉及局部计算，是一个delta规则的清晰的泛化。我们称之为通用的delta规则。出于其他方面的考虑，Parker独立推导了类似的泛化，他称之为学习逻辑（learning logic）.Lee Cun也研究了一个粗略的学习框架。下面的内容，首先要推导通用delta规则，然后通过一些仿真的结果来说明delta规则的使用，最后，我们指明这个基础想法的更长远的泛化。 通用Delta规则这这里提到的学习框架，需要涉及一个输入模式输出模式对的集合（就是训练数据）。系统首先用一个输入向量，输入网络结构，得到一个输出向量；每个输入向量都有一个对应的期望输出向量、或者称作是目标向量；比较实际输出向量与期望输出向量的差别，若没有差别，就不再继续学习；否则，连接的权重修改对应的差值（delta差）。 没有隐藏层节点的网络中的Delta规则先从简单的开始，没有隐藏层节点的网络结构，Delta规则计算。通用计算公式（1）如下： 公式(1): $${\\Delta p}{\\omega {ji}} = \\eta ({t{pj}} - {o{pj}}){i{pi}} = \\eta {\\delta {pj}}{i_{pi}}$$其中： ${t_{pj}}$表示模式对p的输出向量（期望输出）的第j个元素； ${o_{pj}}$表示模式对p的输入向量得到实际输出（输入向量的表达）的第j个元素； ${i_{pi}}$表示输入模式的输入向量的第i个元素； ${\\delta {pj}}$是简化$({t{pj}} - {o_{pj}})$； ${\\Delta p}{\\omega {ji}}$表示输入层第i个节点到输出层第j个节点连接的权重变化； $\\eta$只是一个常量 Hexo对LaTeX的公式兼容性不好，总是编译失败，文章总体就放在CSDN上了。文章地址在http://blog.csdn.net/qust_waiwai/article/details/54692564","tags":[{"name":"BP神经网络","slug":"BP神经网络","permalink":"http://yoursite.com/tags/BP神经网络/"}]},{"title":"简单尝试使用 Snoar Qube","date":"2016-06-22T16:02:07.000Z","path":"2016/06/23/try-Snoar-Qube/","text":"Sonar Scanner 浅尝Sonar Scanner 是一个开源的源代码分析与检测平台，可以监测代码中方法级别，追踪代码中的变量和Bug等。Sonar Scanner的Web地址是http://www.sonarqube.org/，其全称是SonarQube，在网http://docs.sonarqube.org/display/HOME/SonarQube+Platform中有关于SonarQube的简单介绍。 文档支持在SonarQube的主页左侧打开Document的连接，打开后便是说明如何安装Sonar Server。安装的文档部分分为几个模块： Installing DatabaseSonarQube需要数据库的支持，官方提供了几种数据库： Microsoft SQL Server MySQL Oracle PostgreSQL Installing the Web ServerCheck 所有的必备环境，开始安装Web Server Setting the access to the Database Adding the JDBC Driver Starting the Web Server Tuning the Web Server Advanced Installation Features Next Step剩下的步骤就是安装插件和分析代码了！","tags":[{"name":"Sonar Qube","slug":"Sonar-Qube","permalink":"http://yoursite.com/tags/Sonar-Qube/"},{"name":"代码扫描","slug":"代码扫描","permalink":"http://yoursite.com/tags/代码扫描/"}]},{"title":"开始细读《概率图模型》","date":"2016-06-16T15:06:14.000Z","path":"2016/06/16/read-PGM/","text":"终于买了这本大块头，确实不便宜，也不方面携带，但还是买了，内容很多，所以要细细的读书。 这本书被称作是统计机器学习的基础，也是里程碑式的图书，并不打算突击看完，作为一个长期学习计划。 其实，在博客里出现这篇文章，就是凑个数，新生活开始，但是也没有放弃坚持的梦想。","tags":[{"name":"机器学习","slug":"机器学习","permalink":"http://yoursite.com/tags/机器学习/"},{"name":"概率图模型","slug":"概率图模型","permalink":"http://yoursite.com/tags/概率图模型/"}]},{"title":"Ubuntu下Sublime 编辑器添加中文输入支持","date":"2016-01-19T02:40:32.000Z","path":"2016/01/19/sublime-surpport-Chinese-input/","text":"毕业忙活了几个月，开始学习。 ubuntu下原生的sublime text3编辑器不支持中文输入，需要手动设置，参考了别人的做法，修改了一些错误，写一个小的总结。 sublime text 安装在哪里？平时使用subl，记得当时是直接用apt-get安装的，安装路径都是默认的，用命令where查看一下:1where subl 结果是: /usr/bin/subl 但是在bin目录下查看,只有一个subl文件,编辑器的安装文件不在这里. 用locate命令查找subl,结果出来一大堆,也分不清路径. 想不起来以前是怎么安装的了,用history命令查看一下关于sublime的安装命令.1history | grep sublime 偶然发现之前尝试过添加中文输入支持,但是忘记为啥没有继续,然后查找编译好的动态链接库的位置.1locate libsublime-imfix.so 定位到sublime的安装目录: /opt/sublime_text/libsublime-imfix.so 查看sublime的安装目录下的文件:1ls -l 有下面几个文件: -rw-r—r— 1 root root 21K 3月 26 2015 changelog.txt-rwxr-xr-x 1 root root 186K 3月 26 2015 crash_reporterdrwxr-xr-x 7 root root 4.0K 6月 25 2015 Icon-rwxrwxr-x 1 alex alex 13K 6月 25 2015 libsublime-imfix.sodrwxr-xr-x 2 root root 4.0K 6月 25 2015 Packages-rwxr-xr-x 1 root root 4.1M 3月 26 2015 plugin_host-rw-r—r— 1 root root 2.6M 3月 26 2015 python3.3.zip-rw-r—r— 1 root root 19K 3月 26 2015 sublime_plugin.py-rw-r—r— 1 root root 32K 3月 26 2015 sublime.py-rwxr-xr-x 1 root root 4.9M 3月 26 2015 sublime_text 其中sublime_text文件就是subl实际执行的二进制文件,用file命令查看文件类型file sublime_text sublime_text: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked (uses shared libs), for GNU/Linux 2.6.24, BuildID[sha1]=11efbc08b500cd7e41437fe0f7826b584b3e1663, stripped 可以看出是一个ELF文件，就是可执行文件。 也可以查看subl文件类型file subl subl: POSIX shell script, ASCII text executable 可以看出是一个脚本文件，也就是纯文本文件，打开看看。 #!/bin/shexec /opt/sublime_text/sublime_text “$@” 明白了所以然。。。 添加中文输入支持找到了文件的位置，就可以按照网上的教程添加中文支持了，一些文件在https://github.com/zhangxiaoya/sublimeCN。 安装依赖项 1sudo apt-get install build-essential libgtk2.0-dev 编译生成动态链接库,（源码在附录） 1gcc -shared -o libsublime-imfix.so sublime_imfix.c `pkg-config --libs --cflags gtk+-2.0` -fPIC 拷贝 将生成的libsublime-imfix.so文件拷贝到sublime的安装目录，sublime的安装目录是在/opt/sublime_text 修改启动命令 要想使得sublime支持输入中文，就必须加载刚刚生成的动态链接库，可以在在启动的时候，使用命令添加，比如在sublime的安装目录(当前目录的路径是 ‘’.’’)，执行下面的命令， 1LD_PRELOAD=./libsublime-imfix.so ./sublime_text 这样每次启动的时候都使用绝对路径加载动态链接库，有些麻烦。 平时都是使用subl命令，实质上subl是一个具有执行权限的文本文件，用vim打开并编辑。(用where命令查找subl的绝对路径) 1sudo vim /usr/bin/subl 在执行sublime_text命令之前，添加预加载命令 1LD_PRELOAD=./libsublime-imfix.so 这样在每次输入命令subl命令时就预加载中文输入的动态链接库了。 附录12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879//*sublime-imfix.cUse LD_PRELOAD to interpose some function to fix sublime input method support for linux.By Cjacker Huang &lt;jianzhong.huang at i-soft.com.cn&gt;gcc -shared -o libsublime-imfix.so sublime_imfix.c `pkg-config --libs --cflags gtk+-2.0` -fPICLD_PRELOAD=./libsublime-imfix.so sublime_text/*/#include &lt;gtk/gtk.h&gt;#include &lt;gdk/gdkx.h&gt;typedef GdkSegment GdkRegionBox;struct _GdkRegion&#123; long size; long numRects; GdkRegionBox *rects; GdkRegionBox extents;&#125;;GtkIMContext *local_context;voidgdk_region_get_clipbox (const GdkRegion *region, GdkRectangle *rectangle)&#123; g_return_if_fail (region != NULL); g_return_if_fail (rectangle != NULL); rectangle-&gt;x = region-&gt;extents.x1; rectangle-&gt;y = region-&gt;extents.y1; rectangle-&gt;width = region-&gt;extents.x2 - region-&gt;extents.x1; rectangle-&gt;height = region-&gt;extents.y2 - region-&gt;extents.y1; GdkRectangle rect; rect.x = rectangle-&gt;x; rect.y = rectangle-&gt;y; rect.width = 0; rect.height = rectangle-&gt;height; //The caret width is 2; //Maybe sometimes we will make a mistake, but for most of the time, it should be the caret. if(rectangle-&gt;width == 2 &amp;&amp; GTK_IS_IM_CONTEXT(local_context)) &#123; gtk_im_context_set_cursor_location(local_context, rectangle); &#125;&#125;//this is needed, for example, if you input something in file dialog and return back the edit area//context will lost, so here we set it again.static GdkFilterReturn event_filter (GdkXEvent *xevent, GdkEvent *event, gpointer im_context)&#123; XEvent *xev = (XEvent *)xevent; if(xev-&gt;type == KeyRelease &amp;&amp; GTK_IS_IM_CONTEXT(im_context)) &#123; GdkWindow * win = g_object_get_data(G_OBJECT(im_context),\"window\"); if(GDK_IS_WINDOW(win)) gtk_im_context_set_client_window(im_context, win); &#125; return GDK_FILTER_CONTINUE;&#125;void gtk_im_context_set_client_window (GtkIMContext *context, GdkWindow *window)&#123; GtkIMContextClass *klass; g_return_if_fail (GTK_IS_IM_CONTEXT (context)); klass = GTK_IM_CONTEXT_GET_CLASS (context); if (klass-&gt;set_client_window) klass-&gt;set_client_window (context, window); if(!GDK_IS_WINDOW (window)) return; g_object_set_data(G_OBJECT(context),\"window\",window); int width = gdk_window_get_width(window); int height = gdk_window_get_height(window); if(width != 0 &amp;&amp; height !=0) &#123; gtk_im_context_focus_in(context); local_context = context; &#125; gdk_window_add_filter (window, event_filter, context); &#125; 参考 http://www.360doc.com/content/14/1126/15/168576_428234848.shtml","tags":[{"name":"Sublime","slug":"Sublime","permalink":"http://yoursite.com/tags/Sublime/"},{"name":"Ubuntu","slug":"Ubuntu","permalink":"http://yoursite.com/tags/Ubuntu/"},{"name":"中文","slug":"中文","permalink":"http://yoursite.com/tags/中文/"}]},{"title":"Ubuntu14.04 配置Caffe开发环境","date":"2015-11-17T03:39:55.000Z","path":"2015/11/17/init-caffe-develop-kit-on-ubuntu-14-04/","text":"@(Program Primer) 这本是在印象笔记中的一个小系列，当初用于自己整理学习，现在发现实验室有师弟师妹需要，整理成一篇文章。按照顺序，配置顺序是CUDA，OpenCV，MKL，Caffe,中间可能会有各种依赖的安装。 这可能是我在2015年的最后一篇文章，因为我剩下的时间要完成毕业论文！！！ 2017年3月19日更新 Ubuntu14.04 配置CUDA7.15主要还是参考之前的文章在Windows8.1安装配置CUDA。 下面是具体步骤： 下载，在官网上下载安装包，详细的地址在这里，选择与自己的电脑相匹配的条件，最后下载安装包就有1.1G。 我是选择的使用.run安装文件，若是选择使用deb包安装，据说是比较简单，可以参考这里。 若是使用run文件安装，可能会遇到一些麻烦，下面是我的步骤，我是参考了官方文档。 检查硬件是不是支持，我的系统是ubuntu14.04 64位，硬件是NVIDIA GT755M，是支持的，也可以使用命令lspci | grep -i nvidia检查支持否。 停止自身的显卡服务，按照文档里面说的，创建一个黑名单，阻止开源的显卡驱动，然后进入文本模式下，停止显卡服务就可以，使用命令sudo service lightdm stop。（这里需要注意的是，若是笔记本双显卡，会遇到OpenGL的问题，若是双显卡最好不要安装OpenGL，否则就会在登录界面无穷循环，具体原因在文档里面有说明） 然后使用命令安装就可以了，中间让你选择几个文件目录，安装过程还是挺快的。 完成后，输入命令sudo service lightdm start重新开启显卡服务，这时候就可以进入桌面了。 添加环境变量，在.profile或者.bashrc文件的最后添加下面两行。 123export PATH=/usr/local/cuda-7.5/bin:$PATHexport LD_LIBRARY_PATH=/usr/local/cuda-7.5/lib64:$LD_LIBRARY_PATH 测试一下，12345nvcc -Vnvcc: NVIDIA (R) Cuda compiler driverCopyright (c) 2005-2015 NVIDIA CorporationBuilt on Tue_Aug_11_14:27:32_CDT_2015Cuda compilation tools, release 7.5, V7.5.17 需要手动编译所有的样本，花了不少时间。 注意：这是CUDA7.5,其他版本没有测试过。 最后,配置CUDA环境 新建cuda.conf，并编辑：sudo gedit /etc/ld.so.conf.d/cuda.conf添加内容：/usr/local/cuda/lib64/libsudo ldconfig -v 编译SampleCUDA本身提供了很多例子，可以进入目录，make一下，若是这个过程没有问题，基本上CUDA就安装成功了。 主要参考 Caffe + Ubuntu 15.04 + CUDA 7.0 新手安装配置指南 ubuntu14.04安装cuda Caffe + Ubuntu 14.04 64bit + CUDA 6.5 配置说明 Ubuntu 14.04 上安装 CUDA 7.5/8.0 超详细教程 有没有双显卡笔记本在Ubuntu下使用cuda的解决方案？ Ubuntu14.04 安装OpenCV2.92017年3月19日更新 这个最好还是用在Github上的这个编译OpenCV的脚本，很好用。 这个安装OpenCV的方法与以前的有点区别，之前我都是直接编译安装，但是这次需要用到的CUDA，用了别人写好的Shell脚本，但是也有不少的问题，最后还是没有成功安装2.4.9，安装是3.0.0. 主要是参考了下面的两篇文章： Caffe + Ubuntu 15.04 + CUDA 7.0 新手安装配置指南 Ubuntu 14.04 安装 Intel MKL + OpenCV 上面的这两篇文章都是使用的脚本安装的，脚本的功能比较全面，我是手动下载的源码文件，然后修改了了脚本内容，屏蔽了下载，以及修改了解压路径等。其他的都是与在官方网站提供的方式差不多。 以下的参考中，前两篇是安装的Shell脚本，第3和第4、第5都是解决在make过程中的一些问题，不过最终我还是选择了安装openCV3.0.0. 更新【2015.10.05】以上是昨天写的记录，今天更新一下，仔细的研究了一下脚本，跟手动make安装没什么区别，就是在CMake的时候选择了更多的选项，但是始终没有编译样例。不知道是什么原因，我今天又重新卸载，编译了，手动make安装，都是不行。 最后更新，这里还是不要手动安装了，因为需要其他的编译选项，官网提供的编译选项都不包括，所以，还是按照别人的脚本安装吧。 下面是参考的链接： Ubuntu 14.04 安装 Intel MKL + OpenCV Ubuntu14.04安装OpenCV2.9 qust_waiwai的专栏 卸载：是参考的这里 1cat install_manifest.txt | sudo xargs rm 查看安装版本：参考这里 1pkg-config --modversion opencv 参考 Install-OpenCV Install-OpenCV-master Ubuntu 14.04 cuda 6.5 and opencv 2.4.9 Unsupported gpu architecture ‘compute_11’解决方法 Ubuntu14.04 +caffe+cuda 7.0 linux下查看opencv版本 Ubuntu14.04 安装Intel MKLIntel提供的MKL是一个开放的线性代数函数库，也有其他的，可以在参考的几个链接中找到相应的参考资料。 这个安装过程比较简单，但是需要在Intel的官网上申请，学生版的。 要先注册，申请，然后会得到一个序列号，没有序列号是不能使用的，必须使用教育邮箱。 步骤： 申请下载parallel_studio_xe_2016.tar.gz，在官网申请下载，应该先注册 选择平台，在Get Intel® Parallel Studio XE Cluster Edition (includes Fortran and C/C++):这里选择是Linux还是Windows，然后接受4个条件。 进入信息填写界面，输入你的学校的邮箱和学校英文名称 然后提交后进入一个下载界面，选择合适的版本下载，我是选择最新的。 解压：tar -zxvf arallel_studio_xe_2016.tgz，然后拷贝到Home路径下，赋予执行权限 运行一个shell安装脚本，sudo ./install_GUI.sh，按照提示安装即可 一定要注意在下载页面会有一个序列号，要记录下来，在安装过程中会使用的。 最后，配置MKL环境新建intel_mkl.conf， 并编辑： 1234$ sudo gedit /etc/ld.so.conf.d/intel_mkl.conf/opt/intel/lib/intel64/opt/intel/mkl/lib/intel64$ sudo ldconfig -v 参考 BLAS (Basic Linear Algebra Subprograms) BLAS库学习 Quick Reference Guide to the BLAS Ubuntu14.04 安装Glog等一些依赖库Glog是一个轻量级的日志系统，我是第一次接触程序级的日志系统，主要的是参考这里。 下载。原文提供的Google Code，但是我自己的电脑是一直不能登陆，在另外一台电脑上，登陆后发现是原始的源码都转移到GitHub上了，地址在这里。 配置：./configure 这里先暂停一下，遇到一些问题，我在试图编译Glog的时候出现了多种错误，一直没有好的办法解决，另外，我在Caffe的Install指导上，并不是需要自己手动编译Glog和Boost，不像是参考这里和这里讲的都是需要手动编译和安装Glog和Boost。另外，我刚刚按照这里说的，安装了一些函数库： 1sudo apt-get install libprotobuf-dev libleveldb-dev libsnappy-dev libopencv-dev libboost-all-dev libhdf5-serial-dev libgflags-dev libgoogle-glog-dev liblmdb-dev protobuf-compiler 已经将一些函数库安装了，那就是应该不需要手动安装boost \\ glog \\ gflags \\ lmdb这些函数库了。 下面是提示：1234567891011121314151617181920212223242526272829303132333435363738make[1]: Entering directory `/home/alex/Desktop/Glog/glog-0.3.3'test -z \"/usr/local/lib\" || /bin/mkdir -p \"/usr/local/lib\" /bin/bash ./libtool --mode=install /usr/bin/install -c libglog.la '/usr/local/lib'libtool: install: /usr/bin/install -c .libs/libglog.so.0.0.0 /usr/local/lib/libglog.so.0.0.0libtool: install: (cd /usr/local/lib &amp;&amp; &#123; ln -s -f libglog.so.0.0.0 libglog.so.0 || &#123; rm -f libglog.so.0 &amp;&amp; ln -s libglog.so.0.0.0 libglog.so.0; &#125;; &#125;)libtool: install: (cd /usr/local/lib &amp;&amp; &#123; ln -s -f libglog.so.0.0.0 libglog.so || &#123; rm -f libglog.so &amp;&amp; ln -s libglog.so.0.0.0 libglog.so; &#125;; &#125;)libtool: install: /usr/bin/install -c .libs/libglog.lai /usr/local/lib/libglog.lalibtool: install: /usr/bin/install -c .libs/libglog.a /usr/local/lib/libglog.alibtool: install: chmod 644 /usr/local/lib/libglog.alibtool: install: ranlib /usr/local/lib/libglog.alibtool: finish: PATH=\"/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/sbin\" ldconfig -n /usr/local/lib----------------------------------------------------------------------Libraries have been installed in: /usr/local/libIf you ever happen to want to link against installed librariesin a given directory, LIBDIR, you must either use libtool, andspecify the full pathname of the library, or use the `-LLIBDIR'flag during linking and do at least one of the following: - add LIBDIR to the `LD_LIBRARY_PATH' environment variable during execution - add LIBDIR to the `LD_RUN_PATH' environment variable during linking - use the `-Wl,-rpath -Wl,LIBDIR' linker flag - have your system administrator add LIBDIR to `/etc/ld.so.conf'See any operating system documentation about shared libraries formore information, such as the ld(1) and ld.so(8) manual pages.----------------------------------------------------------------------test -z \"/usr/local/share/doc/glog-0.3.3\" || /bin/mkdir -p \"/usr/local/share/doc/glog-0.3.3\" /usr/bin/install -c -m 644 AUTHORS COPYING ChangeLog INSTALL NEWS README README.windows doc/designstyle.css doc/glog.html '/usr/local/share/doc/glog-0.3.3'test -z \"/usr/local/include/glog\" || /bin/mkdir -p \"/usr/local/include/glog\" /usr/bin/install -c -m 644 src/glog/log_severity.h '/usr/local/include/glog'test -z \"/usr/local/include/glog\" || /bin/mkdir -p \"/usr/local/include/glog\" /usr/bin/install -c -m 644 src/glog/logging.h src/glog/raw_logging.h src/glog/vlog_is_on.h src/glog/stl_logging.h '/usr/local/include/glog'test -z \"/usr/local/lib/pkgconfig\" || /bin/mkdir -p \"/usr/local/lib/pkgconfig\" /usr/bin/install -c -m 644 libglog.pc '/usr/local/lib/pkgconfig'make[1]: Leaving directory `/home/alex/Desktop/Glog/glog-0.3.3' 刚刚从其他的机器上，在Google Code上下载了Glog的源码，编译没错，安装的时候提示已将安装了，说明已经安装了，另外两篇文章提示的都是重复安装的，官方文档提示的没错。 那就可以直接安装Caffe了。 Ubuntu14.04 安装Caffe前面的工作，除了Matlab没有安装，其他的都安装好了。下面就按照官网和其他博客里面的说明安装。 下载，在github上下载源码； 修改里面的配置文件，我这里只有cuda和blas变了，所以就只修改了这两项； 编译：make all,正在编译,完事了 编译：make test 编译：make runtest 最后的结果是：12345[----------] Global test environment tear-down[==========] 1641 tests from 234 test cases ran. (287923 ms total)[ PASSED ] 1641 tests. YOU HAVE 2 DISABLED TESTS 上面是比较简单的安装，也没有测试，因为我对Caffe的了解还是不多，下面简单的翻译一下官方的安装说明： 安装在安装和使用caffe之前，最好是瞥一眼这个安装说明，注意各个平台的安装细节，这个安装说明给出了在Ubuntu14.04，Ubuntu12.04，OS X 10.10 ， OS X 10.9 ， OS X 10.8, 和AWS多种平台的安装和使用的细节。官方的Makefile 和 Makefile.config文件都是由社区使用CMake自动完成的。 下面的三个标题详细的介绍安装过程。 对于各个平台的安装细节区别，如下： Ubuntu OS X RHEL / CentOS / Fedora guide 预备条件Caffe有很多依赖的，如下： CUDA在GPU模式下需要； 推荐库的版本是7.0，或者更高，6.×的也是可以的 5.5 或者5.0 也是兼容的，但是太老了 BLAS 基础线性代数函数库，比如ATLAS, MKL, OpenBLAS； Boost，版本1.5以上； OpenCV，版本在2.4以上，包含3.0； 还有一些工具：protobuf, glog, gflags； 输入输出库： hdf5, leveldb, snappy, lmdb； 若是PyCaffe或者Matcaffe另外还需要其他的依赖： PyCaffe：python2.7或者python3.3+；numpy（&gt;=1.7）；boost.python提供的boost Matcaffe：Matlab 带有mex编译器 cuDNN Caffe：是有集成在NVIDIA显卡内的cuDNN加速的最快的Caffe，若是要使用这样的方式加速Caffe，在安装Caffe的时候，修改Makefile.config里面的条件USE_CUDNN := 1，实际上把这一行注释去掉。对于cuDNN R1这些是集成的，但是对于cuDNNE R2请看这里 CPU-only Caffe：若是选择CPU-OnlyCafe模式，修改Makefile.config里面的条件CPU_ONLY := 1 ，实际上把这一行注释去掉，这有利于云部署或者聚类部署。 CUDA和BLASCaffe需要CUDA的nvcc编译器来编译它的GPU模式和GPU操作的CUDA驱动。在安装CUDA的时候，参考NVIDIA的指导，分别安装库和最新的独立驱动，与库绑定的驱动经常是过时的，并且331.×CUDA驱动系列有严重的问题，不要使用。 为了更好的使用，Caffe需要使用 NVIDIA cuDNN.加速，在官网上注册下载并安装，然后继续这个安装说明，当然，在编译的时候需要在Makefile.config修改USE_CUDNN := 1 同时Caffe也需要BLAS作为其矩阵和向量计算的后台，这个库有很多实现，比如： ATLAS ，是一个免费和开源的，同时也是Caffe默认使用的BLAS Intel MKL针对Intel的CPU商业的、优化过的，有免费的实验和学生证书 首先安装Intel MKL 在 Makefile.config设置Set BLAS := mkl OpenBLAS免费的、开源的，安装可能比较费劲，但是是优化的并行的BLAS，能提供加速度。 安装OpenBLAS 在 Makefile.config设置Set BLAS := open Python 和 Matlab Caffe（选择安装）Python安装Python Matlab安装Matlab，并保证它的mex在$PATH。Caffe的Matlab接口可以工作在 Matlab的版本：2015a, 2014a/b, 2013a/b, 2012b. Windows安装非官方的Windows安装参考这里 Ubuntu平台我的系统是Ubuntu14.04，安装这些依赖有自己平台的说明，除了CUDA需要自己编译安装，OpenCV也是自己编译安装，其他的都是可选用apt-get安装。首先安装一些通用的包，这里面包含了一些输入输出库，和Boost等 。 12sudo apt-get install libprotobuf-dev libleveldb-dev libsnappy-dev libopencv-dev libhdf5-serial-dev protobuf-compilersudo apt-get install --no-install-recommends libboost-all-dev CUDA在前面的日记里面记载了安装方式。 BLAS我是安装的Intel的MKL，在官网申请学生版的，选择用gui的方式安装。 python我之前都安装好了，这次就没有关心。 此外，还要安装一些其他工具。1sudo apt-get install libgflags-dev libgoogle-glog-dev liblmdb-dev 这是Ubuntu14.04，对于12.04，这几个库需要自己编译。 1234567891011121314151617# glogwget https://google-glog.googlecode.com/files/glog-0.3.3.tar.gztar zxvf glog-0.3.3.tar.gzcd glog-0.3.3./configuremake &amp;&amp; make install# gflagswget https://github.com/schuhschuh/gflags/archive/master.zipunzip master.zipcd gflags-mastermkdir build &amp;&amp; cd buildexport CXXFLAGS=\"-fPIC\" &amp;&amp; cmake .. &amp;&amp; make VERBOSE=1make &amp;&amp; make install# lmdbgit clone https://github.com/LMDB/lmdbcd lmdb/libraries/liblmdbmake &amp;&amp; make install 编译若是前面的都安装好了，先决条件已经满足了，现在可以编译Caffe，在Github下载Caffe，编辑里面的Makefile.config.example配置文件。注意：若是使用默认的Python，需要把关于Anaconda Python行注释取消。 可以按照下面的命令输入：12345cp Makefile.config.example Makefile.config# Adjust Makefile.config (for example, if using Anaconda Python)make allmake testmake runtest 当要升级的时候，需要重新执行上面的命令，而且之前还要清理一下：1make clean 需要注意的是，需要开启cuDNN加速或者CPU-Only模式的，需要根据前面的提示在构建之前修改配置文件。 要分别用Python和Matlab来编译PyCaffe和MatCaffe，需要在配置文件设定好Python和Matlab的路径。 分布式：运行命令make distribute在需要其他机器上创建分布式目录，目录包含Caffe的header、编译的库、二进制等等用来分布式的东西。 速度：为了加快编译速度，可以在make命令后面添加参数，比如make all -j8 这里面8 就是使用8个线程来并行编译，最好的选择这个数字与自己机器的核心数一致。 好的，现在已经成功安装了Caffe，可以检查 MNIST tutorial和reference ImageNet model tutorial. CMake编译Caffe同时提供了一种非官方的CMake的方式来编译Caffe，替换手动编辑配置文件的方式,CMake的版本必须是2.8.7以上的，【In lieu of 是替换的意思】。步骤如下：12345mkdir buildcd buildcmake ..make allmake runtest 也可以参考这里更详细的说明。 硬件这地方没用！ 参考 喝一杯咖啡真难——我的caffe在ubuntu14.04下安装配置，改错，换包记录 Caffe + Ubuntu 15.04 + CUDA 7.0 新手安装配置指南 Caffe HomePage Installation Ubuntu Installation Installation Compilation 在Ubuntu上安装boost库 Ubuntu下boost库的编译安装步骤及卸载方法详解","tags":[{"name":"CUDA","slug":"CUDA","permalink":"http://yoursite.com/tags/CUDA/"},{"name":"Caffe","slug":"Caffe","permalink":"http://yoursite.com/tags/Caffe/"},{"name":"MKL","slug":"MKL","permalink":"http://yoursite.com/tags/MKL/"},{"name":"OpenCV","slug":"OpenCV","permalink":"http://yoursite.com/tags/OpenCV/"},{"name":"Ubuntu","slug":"Ubuntu","permalink":"http://yoursite.com/tags/Ubuntu/"}]},{"title":"什么是初始化","date":"2015-11-05T14:54:54.000Z","path":"2015/11/05/know-constructor/","text":"@(C Plus Plus) 真的理解初始化吗？Debug确实是一个非常好的学习方式，但是作为主要的获取知识的途径，还是挺危险的。 原因有两种：其中之一是Bug的来源，多数是来自初学编程的同学，或者是师弟师妹，多少是因为对编程语言的理解有误差。这里就有一个心智的问题，根据教科书上描述的编程语言理解完成程序的编写，编译器对程序却有另外一个想法，这两个想法真的是一致吗？（一个不幸的消息是我们学校在大三的时候才开编译原理这门课，大多数学校也是类似的），实际上大多数的错误是这两种心智模式的差异造成的。这样的提法是在Andrew Koenig 的《C Traps and Pitfalls》导读里面写到的，我也一直在发掘我的心智与编译器的心智的差异，这对于理解编程语言、理解计算机原理有很大的帮助，学生阶段这种心智间的差异还是比较低层次的，比如很少有同学直接写出这样的代码((ClassA *)NULL)-&gt;func(0)，这样问题的来源导致知识的膨胀收到了限制。另外一个原因是，很难有较成熟的工程概念，这一点可以用井底之蛙来描述，培养这方面的能力还是需要深入学习和实践的，也就是说需要自己组织知识的来源。总结，我习惯称作是沉淀，用来主动获取知识（Debug是我被动获取知识的策略，俗称懒），技术博客和EverNote是主要的方式，但是文笔水平有限，公布在技术的博客还是需要认真思考！ 笔试中会遇到各种奇葩的问题，比如内存的操作，初始化是怎样完成的。 真的理解初始化吗？还是先看看定义和声明！ 内置类型对象声明：extern int x; 类类型对象声明：extern ClassA A; 函数声明：void func(int a); 类的声明：class ClassA; 还有模板的声明，这个我暂时不擅长，先放一下。 声明仅仅是通知编译器，有这个东西，只是一个符号，但是具体的细节，并不知道，要想知道细节（对于变量，就是分配内存；对于函数和类，需要详细的定义，比如函数体，类的定义），必须知道定义： 内置类型对象定义：int x; 函数定义：给出函数体 类的定义：给出类的定义体 有一点需要注意的是，类的定义，是给出类的定义体，在这个定义内，包含的是成员的声明（内联函数和static const 类型的成员除外），每个成员的实现最好是放在类的实现文件内，比如：1234567891011class ClassB&#123;public: ClassB(); // 构造函数，声明 ~ClassB()&#123;&#125;; // 析构函数，内联实现 ClassB(ClassB&amp; other); // 拷贝构造函数，声明private: int a; // 普通数据成员，声明 const int b; // 常量数据成员，声明，初始化必须在构造函数初始化列表 static int c; // 静态数据成员，声明，只能在类外初始化 static const int d = 0; // 静态常量数据成员，必须这样初始化&#125;; 还有一点经常迷惑，声明是告诉编译器类型说明符和变量名，定义（未初始化）也是给出类型说明符和变量名，但是声明是不分配空间的，定义是要分配空间的，怎么区别：在C++里面，添加关键字extern表示声明，表示这个变量的定义在其他地方，这里只是声明，声明可以多次，但是定义智能有一次。比如：1234int index; // 定义extern int max; // 声明int a = 10; // 定义并初始化extern int c = 11; // 声明，定义，并初始化 理解了声明与定义的区别，声明是简单的描述，是个符号，定义是要分配空间的。但是这里面还没有初始值，在变量的定义的时候我们可以给他们初始化，也可以不给初始化，我喜欢的方式在变量（普通变量，类对象，指针变量等等）定义的时候就要初始化，最小化避免未定义类型的错误！当然，有些变量是必须要在定义的时候就要初始化的，比如：const类型的变量（非类的数据成员），引用类型的变量。 内置类型（build-in type）初始化在CPP语言中，有两种初始化方式，分别是直接初始化（direct-initialization）和复制初始化（copy-initialization），比如：12int a(1); // direct-initializationint b = 2; // copy-initialization 对于内置类型的变量还是比较容易理解的，前者相当于调用构造函数，后者则是复制运算符（=）的特殊用法，在定义式里，表示的是初始化（在创建变量的同时，给他赋予初始值）；在普通的表达式里面，表示赋值操作，是消除原有的数据，赋予新的数据。 两种方式的区别呢？这个对于内置类型的变量，两种初始化的区别不明显。 一个问题，我们没有初始化（在程序中经常是这样的），他的初始值是什么呢？在《C++ Primer（第4版）》中P44有提到： 在函数体外定义的变量的初始值都是0；在函数体内定义的变量不进行初始化，是不确定的值。 在读《程序员的自我修养-编译、链接与库》的时候提到了这样的解释：放在函数体外面的变量都是全局变量（类的数据成员除外）了，全局变量分为两种，一种是已经初始化的，这类的全局变量被放在数据段（data segment），还有就是没有初始化的，这一类被放在bss段，被默认认为是0，但是在数据段给这些都是0 的符号，分配空间没必要，因此都放在了BSS，更多关于BSS的说明参考《程序员的自我修养-编译、链接与库》。 另外，全局静态变量和局部静态变量具有生命周期与全局变量相同，因此，也是类似的表述。 类类型（class type）初始化类的对象的初始化呢？自定义类型的对象的初始化是通过构造函数完成的，这里没有特殊的情况，主要是写法不同，另外就是有两种特殊的情况！ 提供了默认构造函数的形式; 没有提供默认构造函数的形式； 拷贝构造； 赋值操作符初始化。 举个栗子！ 没有提供默认构造函数编译器为了编译顺利通过，提供一个默认构造函数，并不负责初始化成员变量，成员变量是个不确定值。1234567891011121314class ClassA&#123;public: int getA()&#123;return a;&#125;;private: int a;&#125;;int main()&#123; ClassA ca; cout&lt;&lt;ca.getA()&lt;&lt;endl; return 0;&#125; 显示提供默认构造函数自己定义一个空的默认构造函数，只要自己定义了一个构造函数，编译器不再提供默认的构造函数，哪怕自己写的函数什么都不做，因为没有初始化成员变量，所以，内置类型的变量值是不确定的（相当于在函数体内定义一个变量，没有初始化），类类型的对象是调用对应的默认构造函数。123456789101112131415class ClassB&#123;public: ClassB()&#123;&#125;; int getB()&#123;return b;&#125;;private: int a;&#125;;int main()&#123; ClassB cb; cout&lt;&lt;cb.getB()&lt;&lt;endl; return 0;&#125; 显示提供默认构造函数（默认形参）可以提供一个默认形参列表，提供默认，这样比较人性化，我的习惯也是这样。 123456789101112131415class ClassC&#123;public: ClassC(int a = 1):c(a)&#123;&#125;; int getC()&#123;return c;&#125;;private: int c;&#125;;int main()&#123; ClassC cc; cout&lt;&lt;cc.getC()&lt;&lt;endl; return 0;&#125; 下面的形式也是对的，不过我感觉前者更好一些，但是两种形式不能同时存在，否则就会出现二义性（ambiguous），123456789101112131415class ClassC&#123;public: ClassC():c(0)&#123;&#125;; int getC()&#123;return c;&#125;;private: int c;&#125;;int main()&#123; ClassC cc; cout&lt;&lt;cc.getC()&lt;&lt;endl; return 0;&#125; 关于对象的定义形式，也可以按照下面的方式写：123456ClassC cc;cout&lt;&lt;cc.getC()&lt;&lt;endl;ClassC cc1 = ClassC();cout&lt;&lt;cc1.getC()&lt;&lt;endl;ClassC cc2 = ClassC(2);cout&lt;&lt;cc2.getC()&lt;&lt;endl; 提供了构造函数，但是没有提供默认构造函数，怎么办？123456class ClassD&#123;public: ClassD(int d)&#123;this-&gt;d= d;&#125;;private: int d;&#125;; 需要这样使用：12345ClassD cd; // errorClassD cd1(2);cout&lt;&lt;cd1.getD()&lt;&lt;endl;ClassD cd2 = ClassD(2);cout&lt;&lt;cd2.getD()&lt;&lt;endl; 另外两个特殊的情况是拷贝构造和赋值运算符了。 拷贝构造最好是自定义拷贝构造函数和赋值运算符重载，虽然编译器自提供的也可以，但是好的编程习惯还是要保持(演示方便，全用内联了！)！12345678910class ClassE&#123;public: ClassE(int a= 0)&#123;e = a;&#125; ClassE(ClassE&amp; other)&#123;e = other.e;&#125; ClassE&amp; operator=(const ClassE&amp; other)&#123;e = other.e;return *this;&#125; int getE()&#123;return e;&#125;private: int e;&#125;; 拷贝复制：1234ClassE ce;cout&lt;&lt;ce.getE()&lt;&lt;endl;ClassE ce1(ce);cout&lt;&lt;ce1.getE()&lt;&lt;endl; 赋值运算符初始化赋值运算符初始化：123ClassE ce;ClassE ce2 = ce;cout&lt;&lt;ce2.getE()&lt;&lt;endl; 上面部分总结的算是比较正规的操作，也就是在实际工程中常用的，但是在探索C++原理方面，这还是基础，要考虑的内容还有很多，比如：1 构造函数初始化执行顺序（继承体系中）；2 构造函数的初始化列表；3 临时对象的产生；4 构造函数的语义学；5 默认形参与构造函数；6 显示构造函数与隐式构造函数；7 函数签名8 全局变量和BSS 今天实在太冷了，回忆面试的一个某游戏公司的面试题，有点意思，让我发现一些问题。下面程序的输出是什么？ 1234567891011121314151617181920212223242526272829303132333435class Test&#123;public: Test(char* t) &#123; strcpy(str,t); cout&lt;&lt;\"Constructor for \"&lt;&lt;str&lt;&lt;endl; &#125; Test(Test&amp; t) &#123; strcpy(str,t.str); cout&lt;&lt;\"Copy Constructor for \"&lt;&lt;str&lt;&lt;endl; &#125; ~Test() &#123; cout&lt;&lt;\"Destructor for \"&lt;&lt;str&lt;&lt;endl; &#125;private: char str[10];&#125;;Test&amp; func(Test a)&#123; static Test sta(\"static\"); Test t(\"Local\"); return t;&#125;int main()&#123; Test t(\"a\"); Test* b = new Test(\"b\"); func(t); delete b;&#125; 参考信息 《程序员的自我修养-编译、链接与库》 《C++ Primer（第4版）》 《深入探索C++对象模型》 《Effective C++》 《C指针与陷阱》","tags":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"},{"name":"初始化","slug":"初始化","permalink":"http://yoursite.com/tags/初始化/"}]},{"title":"我只会用C++","date":"2015-10-29T15:57:02.000Z","path":"2015/10/29/just-use-Cpp/","text":"我只会C++，是真的，但是不只有C++，也是真的~，我只会Debug，我所掌握的知识，有一半以上是在Debug中学习的。 上午面了某外企技术面，比较轻松，因为是实习转正，整个面试就是在了解我擅长的东西。 以前经过了不少面试，每当我用C++回答“你最擅长什么？”问题的时候，很多面试官说C++只是一门语言，每当问到这里，我通常是说不出话，但是出了C++还有计算机基础比较扎实，其他的我真说不出有什么长处，我没有用过Hadoop，没有使用Spark，Python我只是当作脚本使用来处理我的实验数据，不会用R语言，没有Shell编程经验。。。但是我真的是基础很牢固，我会使用Lisp写程序（可能很多人没听说过，可能有些人很不屑），我最喜欢的事是Debug，本科期间，占用我时间最长的不是开发项目，而是Debug，给自己（我自己写程序很严谨），给其他人（大多数是女生），到大二的时候，我们学院同一级的同学（大约500人）几乎没有人不认识我，原因就是能帮他们解决各种Bug。我是只会C++，不对，不能这么说，我还会Java和C#，只不过我最擅长的是C++—相对，面完了今天下午的一家公司后，我决定添加相对两个字，我确实没有考虑面试官问的问题。 倒不是我喜欢不学习，而是我更喜欢从实践中获取这些知识，面试官问我的问题，我通常会告诉面试官我是如何解答它的，要是在实际项目中我遇到的问题，通常会简单的描述一下问题的根源，我认为这是非常好的学习方式，其实我在大一的时候，就通过帮别人Debug的时候学习知识，更多的是我知道了问题的根源，最常见的问题就是指针（内存），所以我对C++有比较深的感情。另外，我也在读书，很多实验室小伙伴并不是很看好的书，比如《程序员的自我修养》，因为看这本书还被嘲笑过，我从没在意过，因为书中讲到的问题我没遇到过，我很喜欢这种求解新奇问题，就像我可以连续6个小时不吃饭帮人Debug，有些问题，我会解释我在什么书中学到的，我也觉得这是很好的学习方式。 不过，今天晚上的面试确实遇到了一个问题，我没有回答上来，倒不是有多么难，是自己没遇到过，就没有深入的研究这类问题，虽然回答了很多有意思的问题，但是这个问题给面试官留下了不好的印象，真的非常遗憾。 指针问题 比如下面一段代码：12345678910111213141516171819202122232425262728#include &lt;iostream&gt;using namespace std;class A&#123;public: void func1(int x)&#123;cout&lt;&lt;x&lt;&lt;endl;&#125;; void func2(int x)&#123;cout&lt;&lt;y&lt;&lt;endl;&#125;; static void func3(int x)&#123;cout&lt;&lt;x&lt;&lt;\" \"&lt;&lt;z;&#125;;private: int y; static int z;&#125;;int A::z = 0;int main()&#123;// cout &lt;&lt; \"Hello World!\" &lt;&lt; endl; A* a = new A(); a-&gt;func1(2);; a-&gt;func2(2); a-&gt;func3(2); delete a; return 0;&#125; 输出什么？123202 0 这个比较简单，func1直接输出参数；func2输出的是成员变量y，类成员变量被默认初始化为0（非自定义类型）；func3输出的是参数还有一个静态变量，静态变量只能在类外初始化，这一点我知道，但是被private吓到了！ 面试的题目是这样的：12345678910111213141516171819202122232425262728#include &lt;iostream&gt;using namespace std;class A&#123;public: void func1(int x)&#123;cout&lt;&lt;x&lt;&lt;endl;&#125;; void func2(int x)&#123;cout&lt;&lt;y&lt;&lt;endl;&#125;; static void func3(int x)&#123;cout&lt;&lt;x&lt;&lt;\" \"&lt;&lt;z;&#125;;private: int y; static int z;&#125;;int A::z = 0;int main()&#123;// cout &lt;&lt; \"Hello World!\" &lt;&lt; endl; A* a = new A(); delete a; a-&gt;func1(2);; a-&gt;func2(2); a-&gt;func3(2); return 0;&#125; 这样会输出什么？12327234352 0 这个其实func1和func3都比较容易判断，因为对象空间被销毁了，但是类型还是在的，这两个函数都没有使用对象的东西，都是使用类型的成员，所以输出不变，中间这个函数有些奇怪了，因为空间被回收了，但是可能并没有马上被其他程序占用，所以可能还是有可能跟原来的是一样的，但是根据不同平台，也根据不同的编译器，都有不一样，比如我这里是win平台，MinGW编译器，出来这样的结果，每次运行都是不一样的。 const &amp; static看看这下面三种不同修饰符的成员怎么初始化？123456789class B&#123;public: B();private: static int a; const int b; static const int c;&#125;; 静态数据成员必须在类外初始化，而且这是静态变量的唯一的初始化方式，也就是这样：1int B::a = 0; 对于常量，必须在构造函数的初始化列表初始化，在构造函数体内不行，这是是常量的唯一初始化方式，比如这样：123B::B():b(0)&#123;&#125; 最变态的是两个都有的，怎么初始化，首先是静态的，静态的话就不能跟构造函数沾边，既不能放在构造函数函数体，也不能放在初始化列表，然后是常量，常量就必须在初始化列表，这不是矛盾吗？那就在类的定义里面初始化吧。 123456789class B&#123;public: B();private: static int a; const int b; static const int c = 0;&#125;; 这个修饰符的问题应该算是比较常见，但是因为我用的不多，就每太在意，遗憾！","tags":[{"name":"Cpp","slug":"Cpp","permalink":"http://yoursite.com/tags/Cpp/"}]},{"title":"一道面试题","date":"2015-10-18T08:45:48.000Z","path":"2015/10/18/one-interview-problem/","text":"我的智商应该 是没问题，至少表现在各种智力题，比如前几天联想的笔试题，求月份的题目，被我解出来了之后，小伙伴一遇到智力题就找我，还是受大家认可的，Good Brain！可是昨天那道面试题居然当时没想到，难道是当时短路了？ 面试出来，被冷风一吹，瞬间想起来怎么做了！ 原题在网络上也有，我写在我的博客里面，不会提到公司名称，应该不算泄密。 原题描述：给一个m*n的小正方形组成的大矩形（m&gt;n），问这里面有多少个正方形？ 我以为是要写程序求解（在这个题目之前写了一个编程题），然后我的直接想法就是用程序怎么办？折腾了半天，没写出程序！ 然后面试官换了个问题，有多少个矩形？ 我一开始想着从一个维度找：1，2，3， ~， n，然后从另外一个维度：1，2，3，~，m，总共（1+2+~+n）*（1+2+~+m），归纳一下。 这个答案我给出来了，第一个题目的答案其实也是类似的，用分割的方法（两条横向的直线，两条纵向的线段围成一个矩形），正方形要求有一个限制，就是长河宽是一样的，而且题目中m和n是不等的。 正方形的面积最大是nn边长为1：mn;边长为2：(m-1)(n-1);边长为3：(m-2)(n-2); 边长为k：(m-(k-1))*(n-(k-1)) 边长为n：(m-n+1)*(1) 边长为n：(m-(n))*(1) 边长为n：(m-(m-t))*(1) 1&lt;=t&lt;=m-n 边长为n：(m-(m-1))×(1) 脑子短时不好使！！！","tags":[{"name":"智力题","slug":"智力题","permalink":"http://yoursite.com/tags/智力题/"}]},{"title":"数据结构复习--排序","date":"2015-09-05T09:47:01.000Z","path":"2015/09/05/Data-Struct-for-Sort/","text":"@(笔试面试) 数据结构复习 — 排序算法排序算法是在笔试面试中常考，以前在写复习材料的时候，也整理过，但是具体的算法并没有完全测试过，前些天在查找桶排序的算法时，发现别人已经整理的很好了，我拿过来练练手，并记录下来。 插入排序直接插入排序代码如下：12345678910111213void insertsort(int nums[],int n)&#123; // original insert sort int i,j; int key; for(i = 1;i&lt;n;++i) &#123; key = nums[i]; for(j=i-1;j&gt;=0 &amp;&amp; key &lt; nums[j];--j) nums[j+1] = nums[j]; nums[j+1] = key; &#125;&#125; 稍作改进，在每次插入的时候，首先检查与已排序元素的最后一个元素比较，若比最后一个元素大，则不用插入排序；否则进行插入排序，性能没有改进多少，就是程序结构清晰了。12345678910111213141516void insertsort2(int nums[],int n)&#123; // advance insert sort int i,j; int key; for(i =1;i&lt;n;++i) &#123; key = nums[i]; if(key &lt; nums[i-1]) &#123; for(j=i-1;j&gt;=0 &amp;&amp; key &lt; nums[j];--j) nums[j+1] = nums[j]; nums[j+1] = key; &#125; &#125;&#125; 再改进一点，就是二分插入排序，针对前半部分进行二分查找。12345678910111213141516171819202122void binaryinsertsort(int nums[],int n)&#123; // binary insert sort int i,j,low,high,mid; int key; for(int i=1;i&lt;n;++i) &#123; key = nums[i]; low = 0;high = i-1; while(low &lt;= high) &#123; mid = (low+high)/2; if(nums[mid] &gt; key) high = mid-1; else low = mid +1; &#125; for(j =i-1;j&gt;high;--j) nums[j+1] = nums[j]; nums[j+1] = key; &#125;&#125; 交换类排序冒泡排序每次都要交换：123456789101112void bubblesort(int nums[],int n)&#123; // original bubble sort for(int i=0;i&lt;n;i++) &#123; for(int j = 1;j&lt;n-i;++j) &#123; if(nums[j] &lt; nums[j-1]) swap(nums[j],nums[j-1]); &#125; &#125;&#125; 稍微改进一下，若一次冒泡的过程中没有发生一次交换，那就正好有序了。12345678910111213141516171819void bubblesort(int nums[],int n)&#123; // original bubble sort bool flag = false; for(int i=0;i&lt;n;i++) &#123; flag = false; for(int j = 1;j&lt;n-i;++j) &#123; if(nums[j] &lt; nums[j-1]) &#123; swap(nums[j],nums[j-1]); flag = true; &#125; &#125; if(!flag) break; &#125;&#125; 快速排序123456789101112131415161718192021222324int partition(int nums[],int low,int high)&#123; int key = nums[low]; while(low &lt; high) &#123; while(low &lt; high &amp;&amp; key &lt;= nums[high]) -- high; nums[low] = nums[high]; while(low &lt; high &amp;&amp; key &gt;= nums[low]) ++low; nums[high] = nums[low]; &#125; nums[low] = key; return low;&#125;void QuickSort(int nums[],int low,int high)&#123; // quick sort if(low &lt; high) &#123; int pivotloc = partition(nums,low,high); QuickSort(nums,low,pivotloc-1);; QuickSort(nums,pivotloc+1,high); &#125;&#125; 选择类排序简单选择排序12345678910111213141516void selectsort(int nums[],int n)&#123; // simple select sort int minidx; for(int i=0;i&lt;n;i++) &#123; minidx = i; for(int j=i;j&lt;n;++j) &#123; if(nums[minidx] &gt; nums[j]) minidx = j; &#125; if(minidx != i) swap(nums[minidx],nums[i]); &#125;&#125; 递归版的简单选择排序 123456789101112void simplleSelectSortMore(int nums[],int n)&#123; if(nums == NULL || n &lt;= 0) return; int idx = 0; for(int i=0;i&lt;n;++i) if(nums[idx] &gt; nums[i]) idx = i; if(idx != 0) swap(nums[0],nums[idx]); simplleSelectSortMore(nums+1,n-1);&#125; 堆排序堆是一个类似于完全二叉树的结构，但是其中根节点的值要大于其叶子节点的值（大根堆），或者小于其叶子节点的值（小根堆）。正好可以用数组来表示堆结构。堆排序的过程就是一个删除根节点，调整堆结构的过程。 12345678910111213141516171819202122232425262728293031323334void maxHeap(int nums[],int n,int i)&#123; int left,right,largest; left = (i+1)*2 - 1; right = (i+1)*2; largest = left; if(left &gt;= n) return; if(right &lt; n &amp;&amp; nums[largest] &lt; nums[right]) largest = right; if(nums[i] &lt; nums[largest]) &#123; swap(nums[i],nums[largest]); maxHeap(nums,n,largest); &#125;&#125;void createHeadp(int nums[],int n)&#123; for(int i=n/2;i &gt;=0;--i) maxHeap(nums,n,i);&#125;void heapSort(int nums[],int n)&#123; if(nums == NULL || n &lt;= 0) return; createHeadp(nums,n); for(int i=n-1;i&gt;0;--i) &#123; swap(nums[0],nums[i]); maxHeap(nums,i,0); &#125;&#125; 参考的博客里面的下标都是从1开始，我写的程序都是从0开始的，但是并不影响理解程序。 归并排序也是分治思想 1234567891011121314151617181920212223242526272829303132void merge(int nums[],int beg,int end,int mid)&#123; int *arr_l = new int[mid - beg + 1]; int *arr_r = new int[end - mid]; int i,j,k; for(i = 0;i&lt;mid-beg+1;i++) arr_l[i] = nums[beg + i]; for(i = 0;i&lt;end-mid;++i) arr_r[i] = nums[mid + i + 1]; i = 0; j = 0; for(k = beg;k&lt;=end;++k) &#123; if(arr_l[i] &lt; arr_r[j]) nums[k] = arr_l[i++]; else nums[k] = arr_r[j++]; &#125; delete []arr_l; delete []arr_r;&#125;void mergeSort(int nums[],int beg,int end)&#123; int mid = (beg + end) / 2; if(beg &lt;end) &#123; mergeSort(nums,beg,mid); mergeSort(nums,mid+1,end); merge(nums,beg,end,mid); &#125;&#125; 线性时间排序算法计数排序基数排序桶排序参考 CSDN经典排序总结","tags":[{"name":"排序","slug":"排序","permalink":"http://yoursite.com/tags/排序/"},{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/tags/数据结构/"}]},{"title":"快速阅读《Redis设计与实现》 I","date":"2015-09-03T10:26:05.000Z","path":"2015/09/03/fast-read-redis-part-I/","text":"@(Program Primer) 熟悉Redis框架 — 读书部分 I找工作找实习的时候,简历比较容易过关,也幸好有很多同学的内推,但是在面试环节卡住了.可以看出我的简历还是可以过关的,很少出现简历不过的情况,投递阿里巴巴C++研发工程师岗位,不少人接到了要求改变职位的通知,我还是比较顺利的通过了简历这一关.面试被拒还总结一下,也接受一下好友的建议,重点把一些最近很火的东西搞明白.Redis就是其中之一. 反省一下先来自我反省一下,为什么简历比较容易过关,面试总是被拒,从开始今年4月份面实习到现在面内推工作,也不下10家公司了,而且多数都是互联网大佬,也不是所有的都被拒,比如某著名翻译软件,通过了一面,也安排了二面,但是做事从不按常理出牌的导师非不让去,我跟Hr协商了以后安排面试,然后就没有然后了,导师就是个坑.后来也比较顺利的通过了几个其他公司,选了一家研究性的公司实习.有好有坏,反省一下,为毛BAT会被拒绝. 面试技巧,这个真的很关键,我有点孩子气,喜欢开玩笑,面试的时候聊聊就自己放松了,忘记了怎么突出自己的亮点,掉进面试官的坑了,所以,一定要紧张一点,把自己的亮点都表现出来,有东西可以跟面试官聊. 我喜欢C++底层的东西,比如编译器原理,链接器,等等,但这些不是很熟练,只是具备常识,也喜欢C++对象模型,这些东西还是有些涉及,但是这方面的面试比较少,顶多问一下虚函数是怎么实现的,这个我比较清楚,但是描述的不好,没有把动态类型和静态类型解释一下,导致面试官认为我比较水,其实我是真的知道,所以,这期间要重点补充一下这些知识,把思路整理好,重点是对象模型这块. 几乎所有的面试官都对STL各个容器的实现原理非常感兴趣,恰好我对这些并没有太深入的了解,我仅是知道vecor空间如何增长,map是用红黑树实现的,hashmap是类似与hash表,红黑树与平衡二叉树有比较相似,等等,具体原理讲不清楚,下一步重点学习STL基本容器的理论,并且同时学习Redis的五种基本数据对象的原理以及基本使用. 把自己的课题研究重点突出,我的课题是视觉跟踪,使用的方法是压缩感知理论,我可以把压缩感知理论介绍一下,以及我用的字典学习方法,还有我之前的课题是图像超分辨率,很详细的研究过BP神经网络,这一点我可以讲的很清楚. 关于项目,我的项目都不是很难,但是也有自己收获的地方,重点总结一下. 暂时就这些吧,还要刷算法题. Redis读书计划面试几次后受打击还是蛮大的,有些是技术问题的确不会,但是有些确实人品+运气的问题了,运气还是要靠积累的,接受好友的建议,把Redis搞懂,买了黄的一本书,计划这个阅兵假期看完前两部分,并且总结一下.这也算是突击策略了，要达到长远的效果，还是要多编码，时间有限，不过好在自己的数据结构基础比较牢固，这是考研结束后自己独立编写数据结构基础辅导材料的缘故，这样的话突击看完前两部分，效果应该不会太差。节省码字消耗的时间，这次读书笔记就尽量简化。尽量用思维导图代替。 数据结构与对象这一部分的阅读思维导图，基本是根据目录设定的： 简单动态字符串动态字符串（SDS）是对C语言字符串的封装，因为C语言字符串是作为字符串常量，也称作字面值来使用，在内存是存在常量区，不可修改，但是Redis还是需要一个可以修改的字面值，于是就是自己封装了一下，称作简单动态字都穿。SDS用途很广：字符串对象，列表对象，缓冲区（API可以处理 溢出） SDS的定义如下：12345struct sdshdr&#123; int len; // 记录字符的长度 int free; // 记录未使用缓冲区个数 char buf[]; // 字符数组，存储数据区&#125; 由于SDS定义可以看出，不用于传统的C字符串是以一个空字符&#39;\\0&#39;结尾的，C语言字符串求长度函数strlen()就是依据的这个，所以其时间复杂度是O（N），但是SDS求字符串的长度是常数级别。 同时，SDS定义了自己的API，在内部实现避免溢出，而且还修改字符串（主要是长度修改）时采用了空间预分配和空间惰性释放的策略，避免了内存分配和回收的时间消耗。 最后，由于SDS并不像C字符串是假设以空字符&#39;\\0&#39;结尾的，所以，在处理存储二进制的时候就不用担心这个问题了，存储二进制是安全的，而且SDS是与C语言字符串兼容的。 最后，列举SDS的API： sdsnew 创建一个sds，参数是C语言字符串，时间复杂度O(N) sdsempty 创建一个空的sds，时间复杂度O(1) sdsfree 释放给定的sds，时间复杂度O(N) sdslen 求长度，时间复杂度O(1) sdsvail 返回可用字节，时间复杂度O(1) sdsdup 根据一个sds创建一个新的sds，时间复杂度O(N) sdsclear 轻松保存的字符，时间复杂度O(1) sdscat 给定的C字符串链接到sds，时间复杂度O(N) sdscatsds 将一个sds链接到另外一个sds结尾，时间复杂度O(N) sdscpy 将给定的C字符串复制到sds，时间复杂度O(N) sdsgrowzero 用空字符串将SDS扩展至给定长度， 时间复杂度O(N) sdsrange 保留范围内的字符，其他的删除，时间复杂度O(N) sdstrim 给定一个sds和一个C字符串，从sds两端删除在C字符串出现的字符，时间复杂度O(M* N) sdscmp 比较两个sds是否相同，时间复杂度O(N) 链表链表是在数据结构中很常用的数据数据逻辑结构，很多高级编程语言都内置了链表，比如Qt,C++里面的STL，但是在C语言里面没有这样的结构，Redis自己定义链表数据结构。 链表节点的数据定义如下：12345typedef struct listNode&#123; struct listNode* prev; // 指向前一个节点 struct listNode* next; // 指向后一个节点 void value; // 节点的值&#125;listNode; 链表的定义如下：12345678typedef struct list&#123; listNode* head; listNode* tail; unsigned long len; void* (dup)(void *ptr); void (*free)(void *ptr); int (*match)(void *ptr,void *key);&#125;list; 实际上是一个双端队列，并添加了一些其他的属性。 另外，Redis还提供了一些自己的API： listSetDupMethod 将给定的函数设置为节点值复制函数，时间复杂度为O(1) listGetDupMethod 返回当前使用的节点值复制韩式指，时间复杂度为O(1) listSetFreeMethod 将给定的函数设置为节点值释放函数，时间复杂度为O(1) listGetFree 返回链表当前正在使用的节点值释放函数，时间复杂度为O(1) listSetMatchMethod 设置链表节点值的对比函数，时间复杂度为O(1) listGetMatchMethod 返回链表正在使用的节点值对比函数，时间复杂度为O(1) listLength 获取长度 时间复杂度为O(1) listFirst 返回头节点 时间复杂度为O(1) listLast 返回尾节点 时间复杂度为O(1) listPrevNode 返回前置 时间复杂度为O(1) listNextNode 返回后置节点 时间复杂度为O(1) listNodeValue 返回节点的值 时间复杂度为O(1) listCreate 创建一个不含任何节点的链表 时间复杂度为O(1) listAddNodeHead 在头节点位置田间节点 时间复杂度为O(1) listInsertNode 在给定节点后或前面添加一个节点 listAddNodeTail 在尾部添加节点 时间复杂度为O(1) listSearchKey 查找包含一个值得节点，时间复杂度为O(N) listIndex 返回给定索引的节点 时间复杂度为O(N) listDelNode 删除给定值的节点 时间复杂度为O(N) listRotate 将尾部节点弹出，作为头节点，时间复杂度为O(1) listDup 复制一个链表的副本 时间复杂度为O(N) listRelease 释放所有节点 时间复杂度为O(N) 字典字典又称作是符号表，或者MAP（映射），我习惯称作所有的map为映射，其元素是一个成对存在的，一个是键（Key），一个是值（Value）。字典中的键都是独一无二的。 在其他的高级语言中，字典作为基本的数据结构存在，比如在Qt里面，还有C++的STL里面都有，但是在C语言是没有这样的结构的，Redis要使用这样的结构，就自己实现了，而且在Redis里面是，字典被用作数据底层实现，也是哈希键的底层实现(现在我还不清楚哈希键是个什么东西)。 上面说了字典可以被用来做什么，那么字典是由什么做的呢？字典的底层是由哈希表实现的，哈希表是由哈希表节点组成的，有点 晕，容易记混了，不过了解其概念和实现能分清楚了。 哈希表节点的定义如下：123456789typedef struct dictEntry&#123; void *key; // 保存键 union&#123; // 保存值 void* val; uint64_t u64; int64_t s64; &#125;v; struct dictEntry* next; // 指向下一个节点&#125;dictEntry; 那么哈希表的实现如下：123456typedef struct dictht&#123; dictEntry** table; // 哈希表数组，每个元素是一个哈希表节点的指针（解决哈希冲突时链接地址法） unsigned long size; // 哈希表的大小 unsigned long sizemask; // 哈希表掩码，总是= size-1 unsigned long used; // 使用节点数量&#125;dictha; 原材料准备好了，字典的实现是这样构成的：123456typedef struct dict&#123; dictType *type; // 方面实现多态，针对不同类型键值对的函数簇，就是函数指针 void* private; // 针对这些函数的一些可选参数 dictht ht[2]; // 保存两个哈希表，主要是h[0]，h[1]用于再哈希 int rehashidx; // 渐进再哈希过程中的指标，当==-1时，没有再哈希&#125; 在注释中我写了自己的理解。 其中这里的函数指针簇定义为数据结构：12345678typedef struct dictType&#123; unsigned int (*hashFunction)(const void* key); // 哈希函数 void * (keyDup)(void *privdata,const void *key); //复制键的函数 void* (valDup)(void *privdata,const void *obj); // 复制值得函数 void (*keyCompare)(void *privdata,const void *key1,const void *key2); // 比较两个键的值 void (keyDestructor)(void *privdata,void *key); // 销毁键的函数 void (*valDestructor)(void *privdata,void *obj); // 销毁值得函数&#125;dictType; 至于哈希表的的哈希函数是MurmurHash函数，解决哈希冲突的方法是链接地址法。 再哈希是为了避免哈希命中率降低的问题，也就是当装填因子超过一定范围的时候，需要修改一下Hash表，这就是两个哈希表的原因，另外一个用于再哈希，至于哈希策略，在书上29页有详细的描述。 渐进哈希是为了避免繁重的服务器消耗，而是把再哈希的过程分散到查找，添加和删除的过程中，rhashidx就是用来渐进过程的。 字典的API在Page36. 跳跃表这算是一个比较奇怪的数据结构，可以跟双向链表对比着说明： 有一个头节点，双向链表没有； 每个节点有多个前向指针，双向链表只有一个； 这多个前向指针，可以指向任意一个前向的元素，并不局限于前置元素，双向链表的指针只能指向前置元素； 节点数据定义要比双向链表复杂。 跳跃表是一个有序数据结构，效率跟二叉平衡树查不多，但是实现要比二叉平衡树简单。被用作有序集合键的底层实现，另外也被用作集群节点的底层数据结构，用处也就这两个。 条约表节点的定义：123456789typedef struct zskiplistNode&#123; struct zskiplistNode* backward; // 后向指针 double score; // 分值 robj*obj // 成员对象 struct zskiplistLevel&#123; struct zskiplistNode* forward; // 前向指针 unsigned int span; // 跨度 &#125;level[]; // 层&#125;zskiplistNode; 这个参考书中的图比较好理解，层就是多个前向指针的结构体，跨度用来记录两个节点的距离，分值是用来排序的，若分值相同，则根据对象的字典序排序，后向指针只能指向后置元素。 将多个这样的节点组合在一起就组成了跳跃表，是有头节点的，头节点中，这些属性都是无意义的。 header 指向头节点的指针 tail 指向尾节点的指针 level 所有节点中最大的level（不包括头节点） length 所有节点的个数（不包含头节点） 再说一下分值和成员对象，这两个是用来排序的，分值是一个double类型的浮点数，分值是可以相同的，但是对象是不能相同的，对象是一个字符串对象，里面封装了SDS，分值相同的时候，用SDS的字典序排序。 API 参考Page 45； 整数集合整数集是集合键的底层实现方式之一。 Intset 整数集合可以存储三种整数： int16_t int32_t int64_t 整数集合的定义如下：12345typedef struct intset&#123; uint32_t encoding; // 编码方式 uint32_t length; // 元素个数 int8_t contents[]; // 数据存储数组&#125;intset; 整数集合也是有序的，按照其元素值从小到大的顺序，并且是没有重复元素的。 encoding是编码方式，用来指示存储的数据是以上哪三种类型： INTSET_ENC_INT16 表示存储数据是 int16_t; INTSET_ENC_INT32 表示存储数据是 int32_t; INTSET_ENC_INT64 表示存储数据是 int64_t; 升级是比较好玩的设计，整数集合所有的元素必须是同意类型的，若此时是低级（int16_t），那么插入一个int32_t的元素，就会引起升级，所有的元素的空间都开始扩大，原理不好用文字，描述，类似与给定一个字符串，将里面的空格替换成%20，这样的操作，计算好空间从后往前整理。这样的设计是为了节省内存。 但是整数集合没有设计降级操作。 API 参考 P51； 压缩列表压缩列表是我觉得最麻烦的东西，因为它直接对内存以字节为单位进行处理。 压缩列表是列表键和哈希键的底层实现方式的一种，具体看一下表格吧： zlbytes zltail zllen entry1 entry2 … entryN zlend zlbytes 4个字节 记录整个链表的字节数 zltail 4个字节 记录链表的偏移量 zllen 2个字节 节点数量 zlend 1个字节 特殊字符0xFF用于表示链表结尾。 压缩列表节点的定义用下面的结构描述： prrevious_entry_length encoding content previous_entry_length 用来表示每个字节的长度，占用一个字节，或5个字节 encoding 用来表示存储数据类型，与后面的content配套使用 在里面最复杂的就是这个每个节点的长度属性，它会引起连锁更新，当然，概率很小。 API列表在P59 对象前面介绍了几种数据结构，只不过是底层的数据结构而已，但是真正在数据库中使用的还是由这些数据结构组成的对象。 数据结构有： 简单动态字符串 双端链表 字典 压缩链表 整数集合 对象有： 字符串对象 列表对象 哈希对象 集合对象 有序集合对象 根据这些对象的不同，命令决定不同的操作，也就所谓的命令多态。 在Redis里面，对象来组成数据库中的键值对，键和值都是对象，键对象和值对象。 键对象都是字符串对象 值对象可以其五种对象这种的一种 这里来解释一下前面的疑惑，我一开始不知道哈希键是个什么东西，直到看到这一章内容。称作一个键为“某某键”，实际上是这个键对应的值的对象，比如列表键，就是指的该键对应的值是列表对象。使用 Type命令可以查看一个键对应的值的对象类型 Redis每个对象都是一个redisObject结构体123456typedef struct redisObject&#123; unsigned type:4; unsigned encoding:4; void* ptr; ...&#125;robj; 其中type表示对象类型，也就是上面的五种对象类型；encoding表示对象的编码，也就是对象的底层数据结构是由哪几种基本的数据结构实现的。使用命令OBJECT ENCODING查询对象的编码，也就是底层是什么数据结构实现的。 字符串对象的编码可以是：int，raw，embstr。字符串的编码转换是：当数字后面连接字符串，int -&gt; raw；当数字长度变大，或者课编辑 embstr -&gt; raw。字符串命令实现参考P68. 列表对象的编码可以是ziplist，linkedlist。这里还提到了字符串对象是五种对象中唯一可被嵌套使用的对象。编码转换： 所有字符串对象长度都小于64字节 对象元素个数小512 不满足两个条件就用linkedList存储，否则用ziplist存储。 哈希对象的编码可以是ziplist 和hashtable；编码转换： 所有键和值的字符串长度都小于64字节 保存键值对的数量小于512 不满足这个条件，就使用hashtable存储，否则用ziplist存储。 集合对象 的编码可以是intset和hashtable；编码转换： 所有对象元素都是整数 元素个数不超过512 不满足两个条件用intset存储，否则用hashtable存储。 有序集合对象的编码可以是ziplist和skiplist；第一个比较好理解，压缩链表，数据是成对存储的，第一个存储对象，第二个存储分值用来排序。对于skiplist其实是用两种结构结合存储的skiplist和字典，共同组成叫做zset的结构，利用的是两种结构的优点 编码转换： 元素个数少于128个 所有元素的成员都小于64字节 满足条件用ziplist存储，否则用skiplist存储。 命令多态实际上就是在执行名的时候检擦类型，然后调用不同的API。 内存回收和对象共享都是采用引用计数器实现的； 兑现的空转时长就是类似与LRU算法。","tags":[{"name":"Redis","slug":"Redis","permalink":"http://yoursite.com/tags/Redis/"},{"name":"读书笔记","slug":"读书笔记","permalink":"http://yoursite.com/tags/读书笔记/"}]},{"title":"二分查找-- More","date":"2015-08-25T16:30:14.000Z","path":"2015/08/26/binary-search-more/","text":"@(笔试面试) 二分查找在笔试面试中泰常见，比如我在某夹公司实习面试的时候题目，总结写在实习面试三，还有另外一篇关于二分查找上下界，今天又遇到一个比较难的问题,还是关于二分查找,开始自己的思路并不是很明确,有个大概的想法,还不知道具体实施方式,参考了别人的解析,终于有些思路,把自己的想法和思路总结一下. 原始题目: There are two sorted arrays nums1 and nums2 of size m and n respectively. Find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)). 也就是LeetCode的004号题目,定义难度级别是hard.通俗的理解就是求解两个有序数组中位数,若是偶数个,就求两个中位数的平均值. 我最开始的思路是两个指针分别遍历,向中间走,但是题目明确要求使用二分查找,不知道到底这个二分从哪里下手. 还是参考别人的想法吧之前学习的二分查找的对象是一个有序数组,但是这里是两个有序数组,How?把两个数组也看做是一个数组,分成两部分:左半部分和右半部分:12nums1:&#123;0,1,2,...,i-1&#125; + &#123;i,i+1,...,len1-1&#125;;nums2:&#123;0,i,2,...,j-1&#125; + &#123;j,j+1,...,len2-1&#125;; 正如上面的伪代码标识,两个数组分别用两个标志i和j将两个数组分割开,两个数组的左半部分构成整体的左半部分,两个数组的右半部分构成了整体的右半部分:1234567Left Part:nums1: &#123;0,1,2,...,i-1&#125; ;nums2: &#123;0,i,2,...,j-1&#125; ;Right Part:nums1: &#123;i,i+1,...,len1-1&#125; ;nums2: &#123;j,j+1,...,len2-1&#125; ; 但是这里有两个变量,二分查找只有一个变量,How? 二分查找单个数组的中位数,就是找一个点,使得这个点满足:左边数字的个数 == 右边数字的个数,并且,左边的数字 &lt;= 右边的数组. 对于两个数组,其实也是要找到这样的分割点,这里的分割点是两个,因为这里要将两个数组分割组成整体的左右两部分,也就是上面的i和j,使得整体左边的数字的个数 == 整体右边数字的个数,并且,整体左边的数字 &lt;= 整体右边的数字. 不同的是,单个数组可以直接计算得到,两个数组寻找这个点的过程麻烦一点,因为有两个分割点. 两个分割点不好求,那就转换成求解一个分割点,另外一个分割点与之关联,也就得到了,How?通过上面的两个条件: 整体左边的数字的个数 == 整体右边的数字的个数: 也就是(i+j) == (len1-i) +(len2-j),或者总数是奇数的时候:(i+j) == (len1-i) +(len2-j)+1,这样可以用i标识j:j=(m+n+1)/2 - i;这样就转换成一个变量i了. 整体左边的数字 &lt;= 整体右边的数字:即如下:12nums1[i-1] &lt; nums2[j];nums2[j-1] &lt; nums2[i]; 与单个数组不同,单个数组只需要一个计算就可以了,这里需要不断的调整分割点i来满足条件.这个调整i的过程就是利用单个数组二分查找的过程,这样的操作复杂度才能是O(logN).怎样调整i? 这里我们设定i是自变量,那么就设定nums1的长度len1 &lt;= len2.这里的证明不太好说,直白点说,若是len2&lt;= len1再调整i的过程中可能导致j越界. 设定i的二分查找范围,最开始的时候范围是[0,len1],当i==0 的时候,表示数组nums1全部在右边,数组nums2全部在左边,当i==len1的时候,数组nums1全部在左边,数组nums1全部在右边. 循环调整(二分调整):while(min_i &lt;= max_i) 若满足 i&gt;0 &amp;&amp; j nums2[j],这时候数组nums1的左半部分的数字存在大于数组nums2右半部分的数字,需要将i减小,以上判断是在满足两个分界点都不越界的情况的. 若满足 j&gt;0 &amp;&amp; i nums1[i],这时候数组nums2的左半部分的数字存在大于数组nums1右半部分的数字,需要将j减小,也就是要让i变大.以上判断是在满足两个分界点都不越界的情况的. 正常结束:min_i &gt; max_i,此时的i就是正确的分界点,同时也能得到数组nums2的分界点.若总数是奇数个,那么返回max(nums1[i-1],nums2[j-1])(因为左半部分要比右半部分多一个).若是总数是偶数个,那么就要求左半部分的最大值,与又半部分最小值的平均值. 越界结束:若i==0说明左边的最大值是在数组2nums2的[j-1]位置,若j==0说明左边的最大值是在数组1nums1的[i-1]位置.若是总数是奇数,则返回这个左侧的最大值就可以了. 若是偶数,还要求右侧的最小值,若i==len1,则右侧最小值是nums2[j],若是j==len2,则右侧的最小值是nums1[i],若没有越界,则右侧最小值是min(nums1[i],nums2[j]) 不是很好理解,下面是代码实现12345678910111213141516171819202122232425262728293031323334353637383940int len1,len2; len1 = nums1.size(); len2 = nums2.size(); if(len1 &gt; len2) return findMedianSortedArrays(nums2,nums1); int i,j; int mid; int min_i,max_i; int n1,n2; min_i = 0; max_i = len1; mid = (len1 + len2 + 1) / 2; while(min_i &lt;= max_i) &#123; i = (min_i + max_i) / 2; j = mid - i; if(i &gt;0 &amp;&amp; j&lt;len2 &amp;&amp; nums1[i-1] &gt; nums2[j]) max_i = i -1; else if(j&gt;0 &amp;&amp; i&lt;len1 &amp;&amp; nums2[j-1] &gt; nums1[i]) min_i = i + 1; else break; &#125; if(i == 0) n1 = nums2[j-1]; else if(j==0) n1 = nums1[i-1]; else n1 = max(nums1[i-1],nums2[j-1]); if((len1 + len2) &amp; 1) return n1; if(i == len1) n2 = nums2[j]; else if(j == len2) n2 = nums1[i]; else n2 = min(nums1[i],nums2[j]); return (n1 + n2) / 2.0; 参考 LeetCode讨论","tags":[{"name":"实习","slug":"实习","permalink":"http://yoursite.com/tags/实习/"},{"name":"笔试","slug":"笔试","permalink":"http://yoursite.com/tags/笔试/"}]},{"title":"数据结构复习 -- 二叉树","date":"2015-08-25T16:19:48.000Z","path":"2015/08/26/Data-Struct-for-tree/","text":"@(C Plus Plus) 前些天为了准备一些面试，把本科学习的笔记翻出来，是之前参加的魔鬼训练营的学习笔记，重点是关于树的部分，另外还有一些链表和操作系统相关的东西，后续几天认真复习整理一下。手写了代码，还是手动的敲一遍，增加印象。 前序、中序和后序遍历二叉树（递归）首先定义数的节点：123456struct BTNode&#123; int val; BTNode *left; BTNode *right;&#125;; 先序遍历算法（递归）12345678void preorder(BTNode *T)&#123; if(T == NULL) return; cout&lt;&lt;T-&gt;val&lt;&lt;\" \"; preorder(T-&gt;left); preorder(T-&gt;right);&#125; 中序遍历算法（递归）12345678void inorder(BTNode *T)&#123; if(T == NULL) return; inorder(T-&gt;left); cout&lt;&lt;T-&gt;val&lt;&lt;\" \"; inorder(T-&gt;right);&#125; 后续遍历算法（递归）12345678void postorder(BTNode *T)&#123; if(T == NULL) return; postorder(T-&gt;left); postorder(T-&gt;right); cout&lt;&lt;T-&gt;val&lt;&lt;\" \";&#125; 前序、中序和后序遍历二叉树（非递归）树的遍历非递归的方法一般多少采用栈数据结构辅助完成的。其中先序遍历和中序遍历算法比较简单。只需要一个栈就足够了。先序遍历（非递归）123456789101112131415161718192021void dpreorder(BTNode *T)&#123; if(T == NULL) return; stack&lt;BTNode *&gt; s; while(T != NULL || !s.empty()) &#123; while(T != NULL) &#123; cout&lt;&lt;T-&gt;val&lt;&lt;\" \"; s.push(T); T = T-&gt;left; &#125; if(!s.empty()) &#123; T = s.top(); s.pop(); T = T-&gt;right; &#125; &#125;&#125; 中序遍历（非递归）123456789101112131415161718192021void dinorder(BTNode *T)&#123; if(T== NULL) return; stack&lt;BTNode *&gt; s; while(T != NULL || !s.empty()) &#123; while(T != NULL) &#123; s.push(T); T = T-&gt;left; &#125; if(!s.empty()) &#123; T = s.top(); cout&lt;&lt;T-&gt;val&lt;&lt;\" \"; s.pop(); T = T-&gt;right; &#125; &#125;&#125; 后序遍历二叉树的非递归算法要复杂一些，需要用到辅助标记，先序遍历是在入栈之前就访问，中序遍历是在第一次访问栈顶的时候就访问，后序遍历不一样，需要两次访问栈顶的时候才出栈并打印。下面是后序遍历二叉树（非递归）123456789101112131415161718192021222324252627282930313233343536typedef enum&#123;L,R&#125; tagtype;struct stacknode&#123; BTNode *ptr; tagtype tag;&#125;;void dpostorder(BTNode *T)&#123; stacknode x; stack&lt;stacknode&gt; s; if(T == NULL) return; do &#123; while(T != NULL) &#123; x.ptr = T; x.tag = L; s.push(x); T = T-&gt;left; &#125; while(!s.empty() &amp;&amp; s.top().tag == R) &#123; x = s.top(); s.pop(); T = x.ptr; cout&lt;&lt;T-&gt;val&lt;&lt;\" \"; &#125; if(!s.empty()) &#123; x = s.top(); T = x.ptr; s.top().tag = R; T = T-&gt;right; &#125; &#125;while(!s.empty());&#125; 构造二叉树给定一个二叉树的先序遍历和中序遍历序列，构造一颗二叉树。正好创建一个二叉树验证前面的程序。程序代码如下：123456789101112131415161718BTNode *CreateTree(int pre[],int in[],int beg1,int end1,int beg2,int end2)&#123; if(beg1 &gt; end1 || beg2 &gt; end2) return NULL BTNode *p; p = new BTNode; p-&gt;val = pre[beg1]; p-&gt;left = p-&gt;right = NULL; if(beg1 == end1) return p; int k = beg2; while(pre[beg1] != in[k]) ++k; int t = k - beg2 + beg1; p-&gt;left = CreateTree(pre,in,beg1+1,t,beg2,k-1); p-&gt;right = CreateTree(pre,in,t+1,end1,k+1,end2); return p;&#125; 完全二叉树遍历给定一个完全二叉树，存储方式是使用数组方式存储的，空节点存储的是0.题目要求是给定两个节点的位置i和j，求解这两个节点的最近的双亲。1234567891011int comparent(int i,int j)&#123; while(i != j) &#123; if(i &gt; j) i /= 2; else j /= 2; &#125; return i;&#125; 求二叉树的节点数用递归的方法比价简单1234567891011int finnum(BTNode *T)&#123; int lcount; int rcount; if(T == NULL) return 0; else if(T-&gt;left == NULL &amp;&amp; T-&gt;right == NULL) return 1; else return finnum(T-&gt;left) + finnum(T-&gt;right);&#125; 层次遍历二叉树和树的高度12345678910111213141516171819202122232425262728void findlevel(BTNode *T,int &amp;level)&#123; BTNode* que[maxlength]; int front = 0; int rear = 0; int k; if(T != NULL) &#123; que[(rear++)% maxlength] = T; k = rear; level = 0; &#125; while(rear != front) // 队列空 &#123; T = que[(front++) % maxlength]; cout&lt;&lt;T-&gt;val&lt;&lt;\" \"; if(T-&gt;left != NULL) que[(rear++)% maxlength] = T-&gt;left; if(T-&gt;right != NULL) que[(rear++)% maxlength] = T-&gt;right; if(k == front) &#123; k = rear; level ++; cout&lt;&lt;endl; &#125; &#125;&#125; 参考 本科参加魔鬼训练营笔记","tags":[{"name":"二叉树","slug":"二叉树","permalink":"http://yoursite.com/tags/二叉树/"},{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/tags/数据结构/"}]},{"title":"计算一个整数因子个数","date":"2015-07-12T15:17:01.000Z","path":"2015/07/12/calculate-the-number-of-devisor-of-a-integer/","text":"今天说好的帮小马同学做微软夏令营的机试题目，还好，时间来的及，只是。。。题目略难。暂时搞不定啊！！！ 小马同学分给我的题目是求解一个整数的因子个数的问题，这个我以前在《编程之美》上见过，整理下思路，参考一下别人的解释，写出自己的源码。 记不清在《编程之美》多少页了，但是相关题目大概还是记得，就是求解一个整数的阶乘结果又多少个0，实际就是求解质因数2和5的个数，不过这里扩展了一下。 以下是我写的测试程序；在机器上测试了一下，要比直接循环判断的方法快的多。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;iostream&gt;#include &lt;map&gt;using namespace std;int w[6600] = &#123;2,3,5,7,11,13,17,19,23,29&#125;; // 初始化素数表int n = 10; // 素数表边界bool isPrime(int n) // 判断是否为素数&#123; for(int i =0;w[i] * w[i] &lt; n ;++i) if(n%w[i] == 0) return false; return true;&#125;int getDivisorNum(int m)&#123; map&lt;int, int&gt; ma; // kay存放素因子，value存放分解个数 for(int i=0; m!=1 &amp;&amp; i&lt;n; ) // 分解因子,n为素数表边界 if(m%w[i]) i++; // w[i]不是a的因子,则尝试素数表中下一个素数 else ma[w[i]]++, m/=w[i]; // 是因子，则a的该素数个数加1,a除去该素数 if(m&gt;(1&lt;&lt;16)) // int 就没必要 ma[m]++; // 大于2^16的素因子最多只有一个 int sum = 1; map&lt;int,int&gt;::iterator it; for(it = ma.begin();it!=ma.end();++it) sum *= (1+(*it).second) ; return sum;&#125;int main()&#123; int a = 4; for(int i=31;i&lt;(i&lt;&lt;16);i+=2) // 计算素数表 if(isPrime(i)) w[n++] = i; for(int i = 1;i&lt;10000;++i) cout&lt;&lt;getDivisorNum(i)&lt;&lt;endl; return 0;&#125; 当然，微软不可能出这么简单的题目，重点在后面，测试用例有一部分是大约10的16次方的，也就说用int类型是不能表示的。上面的程序是不行了，需要考虑大数问题。这个暂时不考虑了，其实求解这个问题的关键是一个数学定理： 一个整数的所有因子数等于其每个素因子的个数加一之后的乘积(1+p1)(1+p2)…(1+pn)，其中p1、p2、…、pn分别为该整数的所有n个素因子P1、P2、…Pn的相应个数。 参考","tags":[{"name":"实习","slug":"实习","permalink":"http://yoursite.com/tags/实习/"},{"name":"笔试","slug":"笔试","permalink":"http://yoursite.com/tags/笔试/"}]},{"title":"《深入探索C++对象模型》第六读书笔记","date":"2015-07-09T14:58:49.000Z","path":"2015/07/09/read-the-semantics-of-runtime/","text":"@(读书笔记) 中间项目耽误了很大一段时间，今天学校算是正式放假了，放松一下（虽然我们依然没有假期）只是心里的感觉，可以暂时放下一会项目，做一些自己喜欢的事情，比如今天终于把《深入探索C++对象模型》看的差不多了，写一些读书笔记。 执行期语义学这一章其实是看了两遍，第一遍没看懂这个执行期的语义学到底是是个什么东西，第二遍是在今天早上看的（实在不想写某项目的代码），果然还是早上的头脑清楚，效率很高，思路非常清晰，这一章的内容就是讲了程序在运行期间的临时变量以及对象如何构造与析构的。 本章开始用一个程序例子来说明，一个简单的语句在被编译器理解后变成了由一些“原子操作”构成的一个“胖子“，以及各种临时变量的生成。 本章的内容就是在我们写的程序在执行期间是被编译器如何解释的，相对于前几章的内容，这些更”动态“，比如第一节是讲的对象的在执行期间是如歌调用构造和析构函数，第二节是介绍的new和delete是在堆上分配空间，如何调用构造和析构函数，最后一节则是重点介绍了程序常遇到的临时对象的问题。这些东西相对与对象在内存中分布，函数在内存中的地址等，更抽象一些，更像是一些”动作“，而前面的知识更像是这些”动作“的”基本要领“，或者称作是”技术指标“。 对象的构造与析构这里主要是介绍对象是在什么时候调用构造与析构函数的，换做是编译器语言：就是对象的构造函数和析构函数在编译期间被安插在程序的具体位置（因为对象的构造函数和析构函数是编译器来调用的，程序中还是不好直接显示直接调用他们）举个最简单的例子，在声明对象后很快就要对它初始化（构造），在它的生命周期结束前要对它销毁（析构）123456&#123; Point pt; // Constructor may be here ... // Destructor may be here&#125; 当然了，程序结构不是都这么简单的，比如常见的程序结构：条件，循环，Switch结构，甚至还有goto语句，对象出现的位置只有一个，但是消失的位置可能是多个中的一个（不确定），编译器会在任何可能的位置添加析构函数。 全部变量上面这些还是动态的局部变量，非常普通，不需要额外的处理。但是当遇到全局对象（非内置类型）就不这么简单了。 普通的变量不需要有初始值，只要在程序运行到之前给它初始值就可以了，也就是在执行期执行构造函数。 普通的动态变量是存放在堆栈中的，他们在程序执行的整个周期的一小部分，但是全局变量是伴随整个程序执行的，甚至在main函数之前他们就已经初始化好了，他们不是放在堆栈中，而是放在程序的data segment也就是数据段中。 全局变量是通过常量表达式设定初始值的，所谓的常量表达式是指在变异期间就知道表达式值的表达式（构造函数不是常量表达式）。 全局变量是程序的实体的一部分，是在编译期间就初始化的，所以全局变量是必须静态初始化的。 那么怎么做呢？cfront的方法还是比较典型的。 为每个需要静态初始化的对象产生一个_sti()函数，在这样的函数里面直接调用其构造函数，或者用内联的方式执行初始化工作。需要注意的是，这里每个变量的_sti()都是经过重命名处理的，比如这里是添加文件名和变量名。 同样，为每个需要静态内存释放的对象产生一个_std()函数，在这个函数里面直接调用其析构函数，或者内联的方式展开函数。同样这个函数做了重命名处理。 提供这样的函数，在程序开始的时候调用所有的_sti函数，：_main()函数提供这样的操作，将所有的_sti组合在一起。同样也提供一个_exit()函数，将所有的_std()函数。 书中的一个图看失去是非常形象的，但是仔细的想象，全局变量是静态初始化的，而书中给的图的意思是，在main函数内执行_main()函数，在main函数结尾前执行_exit()函数，但是全局变量应该是在main函数执行前就已经完成初始化了，这里的图有点迷惑，还是看看《程序员的自我修养—编译、链接、装载》，那里讲的比较详细点。 暂且不考虑上面的问题，还有一个问题是怎么收集所有的_sti()和_std()函数，书中将的有点乱，我认为是有 程序来读取每个object文件，读取其中的符号表，然后将符号表中关于_sti()和_std()的函数提取出来，存储在一个”跳离表格“中，然后，重新启动编译器，重新编译，将包含”跳离表格“的文件一起编译链接。 以上是对于类的对象，但是对于noclass 对象和对于支持虚基类的对象，都是不同的，其中noclass 对象没有构造函数，虚基类的指针比较复杂。书中也没有 详细的介绍这里。 最后就是静态初始化的缺点： 这些对象不能放在try块内。 有些全局变量的依赖顺序要考虑好，复杂度是个问题。 局部静态对象静态局部对象有写特点： 存在一个函数内，生命周期是整个程序的生命周期，但是作用域只是在这个函数内部。 这个函数可能被调用多次，但是静态局部变量只能初始化一次，析构一次。 怎么办？设置一个辅助变量，用来标识静态局部变量是否已经被构建和析构。 静态局部变量的生命周期是整个程序的生命周期，但是作用范围确是只是在函数体内。在程序结束的时候是没办法直接调用静态局部变量的析构函数的。 怎么办？保存静态局部变量的指针。 最后还提到了，如何根据构建顺序，然后逆序析构，显然，在静态编译期间是无法预知顺序的，只有在程序执行的时候保存一个初始化顺序表。 对象数组1Point knots[10]; 若一个数组是由一些带构造函数的类的对象构成，那么在初始化数组的时候，需要挨个初始化每个元素。当然，要是类没有定义构造函数和析构函数，那就无所谓了，它们的初始化与初始化一个内置类型的数组的消耗是一样的。 在早期的Cfront中，是专门有个函数来完成初始化的（调用构造函数）：vec_new，比较新的编译器会提供两种函数，另外一种是vec_vnew，是用来初始化带有虚基类的类的对象数组的。其中一个函数原型如下：1234567void*vec_new( void* array, // 起始地址 size_t elem_size, // 每个对象大小 int elem_count, // 元素个数 void (*constructor)(void*), void (*destructor)(void*,char)) 其中array可以是具名数组的地址，也可以是new在堆上分配的空间，此时array=0。 这里有一个析构函数的函数指针，我一直怀疑是不是写错了。因为会有一个类似的函数：vec_delete或者一个vec_vdelete来调用析构函数。 在写程序的时候，也会给程序赋初值，也许会只有一部分有初值。那就把有初始值的部分设定好，剩余的部分用vec_new函数来完成。 new 和delete运算符int *pi = new int(5);其实这个语句是分为两个步骤完成的：12int *pi = __new(sizeof(int)); // 分配空间*pi = 5; // 赋值 但是实际上是要判断是否分配内存成功的：123int *pi;if(pi == __new(sizeof(int))) *pi = 5; delete也是类似的：12if(pi != 0) __delete(pi); delete 操作是不会对0指针做删除操作的。而且也不会把指针修改为0的。 对于数组也有类似的操作，需要注意的是函数vec_new是只有在类对象数组，且该类提供了默认构造函数的时候才会调用。 删除数组的时候需要提供[]在数组名前，其实也可以在这里面指定元素的个数，不过现代的编译器都是忽略这个元素个数。 什么是cookie？ 不知道个数怎么析构呢，原来是在函数vec_new的时候会存储一个cookie用来存放元素个数。 placement Operator new实际是重载new 操作符。1Point *pt = new(arena)Point; 其中arena应开辟的空间的地址，用来存储一个新创建的Point对象。 这个函数实际上只是返回了这个地址，函数的原型可以理解为这样1234void* operator new(size_t,void* p)&#123; return p;&#125; 表面是看起来确实如此，但是实际上还有另外一层语义，就是类型转换，并且执行构造函数。实际的代码可能类似于这样的：123Point *pt = (Point*)arena;if(pt !=0) pt-&gt;Point::Point(); 上面的解释其实是基于这样的假设：arena是新开辟的空间，没有任何污染。 但是若要使这个arena空间已经存在了一个对象怎么办？需要保证原来的对象被析构，delete这块区域，早期的delete会将这块内存也删除，这块内存也没法用了，不可行直接调用destructor，可以解决这个问题。 这还不算是麻烦的，当这块区域是一个基类的对象。。。 临时对象这块讲的有点拗口，还不是特别清楚作者的思路，先不写了。 彩蛋 今天女神张俪来我理工拍新戏，大晚上的，蚊子满天飞，一个镜头拍了N遍，好不容易啊！","tags":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"},{"name":"对象模型","slug":"对象模型","permalink":"http://yoursite.com/tags/对象模型/"}]},{"title":"二分查找上界和下界","date":"2015-06-26T02:08:10.000Z","path":"2015/06/26/upper-bound-and-lower-bound-of-binary-search/","text":"@(笔试面试) 在算法题里面,最常用的算法也就是二分查找,以及二分查找的变种,时间效率高,而且占用常量空间.但是二分查找也有一个问题,需要查找的数列必须是有序的,不然需要提前进行排序的.关于查找一个元素是否在数列内,这样的算法是比较基础的了,较为复杂的是含有重复元素的时候怎么办? 一般的二分查找先举一个例子,一个给定一个有序数组,查找是否存在一个元素.12345678910111213141516171819int BinarySearch_basic(vector&lt;int&gt; &amp;nums,int target)&#123; int len = nums.size(); if(len == 0) return -1; int low = 0; int high = len -1; while(low &lt;= high) &#123; int mid = (low + high) &gt;&gt;1; if(nums[mid] == target) return mid; else if(nums[mid] &gt; target) high = mid - 1; else low = mid + 1; &#125; return -1;&#125; 算是经典的二分查找程序了,每一次都折半查找空间,直到遇到相等的元素,返回该元素的下标,否则,查找范围不对其了,返回-1.二分查找相对顺序查找的一个重要的优点就是减少了比较次数,比较次数正是查找算法复杂度的关键,减少查找次数就是降低时间复杂度. 二分查找寻找下界上面的例子很简单,没有重复的元素,但是若序列中有重复的元素,那就不能简单的返回其中一个下标了,用户需要的是返回重复元素的起始下标和终止下标,用来表示范围,同时还要保证在不存在的情况下的鲁棒性.先是利用二分查找寻找下界:相对于基本的二分查找,一个重要的不同是,就是在找到相同的元素的时候,不能直接返回其下标地址,还需要不断的移动上边界,直到查找范围不能满足条件,下面是我的代码:12345678910111213141516171819int findLower(const vector&lt;int&gt; &amp;nums, int target)&#123; if(nums.size() &lt; 1) return -1; int low = 0; int high = nums.size() -1; while(low &lt;= high) &#123; int mid = (low + high)&gt;&gt;1; if(nums[mid] &gt;= target) high = mid - 1; else low = mid +1; &#125; if(low &lt; nums.size() &amp;&amp; nums[low] == target) return low; else return -1;&#125; 简单的介绍一下:当中间元素大于或者等于目标元素的时候,都需要用mid-1来替换查找上界,结束的条件是high&lt;low,这时候需要检查是否满足条件; 若low已经超过序列的长度,则肯定是不存在的(high没有移动,若存在的话,high至少移动一次!),那么越界呢?high是一直在降低的,所以也可能变成-1,为什么不见查呢?这里不需要特别的处理,因为所有的元素都是大于或者等于目标元素值的,是否存在,只需要下面一个检查条件. 若low没有越界,则从下标为low开始,元素值都是大于或者等于目标元素值的,这是检查low位置的元素值,若与目标元素值相等,则low就是下界位置,否则是不存在元素的. 二分查找寻找上界查找上界与查找下界非常相似,唯一的不同是,当找到相同的元素的时候,要移动的是查找下界,查找下界变大,直到查找范围不满足条件.下面是我的代码:12345678910111213141516171819int findUpper(const vector&lt;int&gt; &amp;nums, int target)&#123; if(nums.size() &lt; 1) return -1; int low = 0; int high = nums.size() - 1; while(low &lt;= high) &#123; int mid = (low + high) &gt;&gt; 1; if(nums[mid] &lt;= target) low = mid + 1; else high = mid -1; &#125; if(high &gt; -1 &amp;&amp; nums[high] == target) return high; else return -1;&#125; 当遇到相等的元素,查找范围的下界都用mid+1替换,这样下界不断的增大,直到low&gt;high.这时候也需要检查条件: 若存在相同的元素,应该是low向上移动的,所以,在存在元素的情况下,是不可能high变成-1的(low没有移动),这种越界情况下是不存在元素的,所以返回-1,那么low呢?跟上面的情况 类似了,需要看high位置的元素了. 在high没有低于下界的情况下,此时low位置前面的元素肯定是小于或者等于目标元素的.此时high正好在low前面的一个位置,只需要检查这个位置的元素,若与目标元素相等,则上界就是high了,否则,其他的元素更不满足了(递增),返回-1. 其他还有一种应用,就是给定一个序列,有序,给定一个值,寻找第一个比这个值大的元素的位置,或者比该元素小的最大的那个数值的位置.这个题目是上次我面试的时候遇到的,文章已经详细的描述了.本文寻找上下界的方法也可以用于求解该问题,但是缺点是,若不存在的话就不好找了,需要稍微对前面两个方法修改. 比如,第一个比目标值大的元素的位置:12345678910111213141516int func1(const vector&lt;int&gt; &amp;nums, int target)&#123; if(nums.size() &lt; 1) return -1; int low = 0; int high = nums.size() - 1; while(low &lt;= high) &#123; int mid = (low + high) &gt;&gt; 1; if(nums[mid] &lt;= target) low = mid + 1; else high = mid -1; &#125; return low;&#125; 可能所有的元素都比目标值小,上面的程序返回的是序列的最后一个元素的下一个位置,若需要返回-1的话,需要稍微修改一下最后一句就好了. 比目标元素小的最大的值的位置:1234567891011121314151617int func2(const vector&lt;int&gt; &amp;nums, int target)&#123; if(nums.size() &lt; 1) return -1; int low = 0; int high = nums.size() -1; while(low &lt;= high) &#123; int mid = (low + high)&gt;&gt;1; if(nums[mid] &gt;= target) high = mid - 1; else low = mid +1; &#125; if(low &lt; nums.size() &amp;&amp; nums[low] == target) return high;&#125; 若素有的元素都比目标元素大,则实际上返回的是序列第一个元素的前面的一个位置,也就是-1,所以不用修改了.","tags":[{"name":"实习","slug":"实习","permalink":"http://yoursite.com/tags/实习/"},{"name":"笔试","slug":"笔试","permalink":"http://yoursite.com/tags/笔试/"}]},{"title":"你的生活你决定","date":"2015-06-14T03:18:36.000Z","path":"2015/06/14/it-s-up-to-you/","text":"上午的时间就这么浪费了，有些困，看了几篇文章，剩下点时间写一篇文章，这也是在新博客的第一篇与技术无关的文章，记录在生活中的点滴，充当记忆。前两天失眠的时候想了一些事情，有些是别人向我我吐槽，也有些是我自己的事情，也是这些事情困扰了我好一阵，今天看到一篇微博，突然感觉心情舒服了很多。 说点什么快要毕业了，很多事情都要忙，比如实习、论文等等诸如关于生计之类的吧，时间真是显得捉襟见肘，各种焦虑一下子全都来了，脑壳本来就不大，容不下这么多事，结果失眠了。 最近逛学校论坛，常发现各种情感贴，难道是毕业季的原因。理由无非是对另一半的各种不满，发帖的原因也就是在论坛寻找关注，希望得到想要的答案，依我看，其实他们已经知道了答案，只不过不敢下决心罢了。 其实我也经历过这样的问题，相对来说，我没有二到在论坛上发帖，只是静静的想自己的问题。 对于我的问题，还有网友的问题，我还不能总结一个比较精确的原因，或许这就没什么原因，如果非要是有一个人承担责任，那最好就是自己吧，在这个物欲横流的社会，稍有一些浮躁，就会引起连锁反应。 怎么解决这样的问题？我通常的回答是：把自己做好吧。 当你又瘦又好看，钱包里都是自己努力赚来的钱的时候，你就会恍然大悟，哪有时间患得患失，哪有时间猜东猜西，哪有时间揣摩别人，你若盛开，蝴蝶自来，你若精彩，天自安排。 怎么办青春就这么短短几年，别让焦虑给糟蹋了，多读书，多写点东西，把自己做好就够了，别人喜欢你，那是因为你自己！ 生活都要继续下去，多点正能量，多读书，把自己做好，就够了！ 结束语 这个时候才发现，理工了整个青春，却还没有文艺一次！","tags":[{"name":"生活","slug":"生活","permalink":"http://yoursite.com/tags/生活/"}]},{"title":"在Windows8.1上安装CUDA","date":"2015-06-10T10:42:40.000Z","path":"2015/06/10/install-on-windows8-1/","text":"@(Program Primer) 需要对比试验，但是作者提供的程序需要是使用CUDA，在两个台式机上测试，都不能通过，笔记本的显卡是配置最高的，在自己的笔记本上配置环境跑程序，刚才尝试了一下，还好，能用了。在Windows平台上配置环境挺简单的，还是记录一下，方便以后查看。 检查显卡虽然是N卡，但是还是检查一下显卡是否支持。我的机器的基本配置： 处理器 intel i5 四线程 内存 4GB * 2 显卡 NVIDIA Geforce 755m 2GB 系统 Windows 8.1 64 bit 中文版 也可以在设备管理器中查看自己机器的显卡。 在NVIDIA的官方网站查看显卡是否在支持的列表中。但是，这个表不是特别全。也可以在其硬件设备网站中查看是否支持。 或者使用GPU-Z查看是否支持，不过这个软件也是有问题。最好的是查看硬件的支持信息。 不过也有在百度上直接问的，比如这位同学。 注意： 下载的安装包实际上是安装三个东西 Toolkit 各种工具的集合，提供了矩阵计算的各种工具 GDK 提供一些库函数，我看的意思貌似 是ML（Machine Learning）的库，其实不是啦，是NVIDIA Management Library的意思。 Samples 提供了一些例子 开始安装检查发现显卡支持CUDA，那果断安装。 在NVIDIA的官网，上找到CUDA ZONE，可以在这里了解更多关于CUDA的知识； 在CUDA下载页面选择合适的系统平台，下载对应的开发包，我下载的是Win8.1版本的，但是我发现怎么只有Win8.1下有链接，其他的系统平台下没有链接，难道都是一样的？ 安装，整个安装过程比较简单，就类似于普通的软件安装，但是要提醒一下，一定要安装Visual Studio 2010 或者更高版本，比如Visual Studio 2012 和 Visual Studio 2013，CUDA7.0 都是支持的。安装路径也是可以选择的。 安装过程看电脑的性能了，我大约安装了10多分钟。 验证安装，打开命令提示框（就是cmd），输入命令nvcc - V，查看CUDA的版本。若是安装正确的话，会出现下面的结果；若不正确，我也不知道啦。 12345C:\\Users\\username&gt;nvcc -Vnvcc: NVIDIA (R) Cuda compiler driverCopyright (c) 2005-2015 NVIDIA CorporationBuilt on Mon_Feb_16_23:00:53_CST_2015Cuda compilation tools, release 7.0, V7.0.27 其他验证方式网上的教程还给了其他的验证方式，比如这篇文章提到了用deviceQuery.exe验证，我找了半天也没找到这个可执行程序，后来发现原来这是一个例子，按照其他文章说的，在安装的时候就把例子也给编译了，我仔细的检测，发现我的没有编译，只能自己编译了。 在例子的安装目录下，找到解决方案的名字。比如我的例子的安装路径是D:\\Application\\ProgramData\\NVIDIA Corporation\\CUDA\\Samples\\v7.0\\，若版本号跟我的一样的话，应该是有三个解决方案，对应不同的版本，比如我的有Samples_vs2010.sln、Samples_vs2012.sln和Samples_vs2013.sln，我的机器只是安装了Visual Studio 2010因此，只能打开第一个解决方案。 开始漫长的编译过程，选择Visual Studio 2010的生成-&gt;生成解决方案或者直接按F7键，开始Build。 Visual Studio这个环境好用，但是也会有各种奇葩的错误，在构建例子的过程中，有10个例子没有成功，先不管了，绝大多数都成功了。 下面是我的构建日志的最后部分：12345678...144&gt; 正在删除文件“x64/Debug/alignedTypes.unsuccessfulbuild”。144&gt; 正在对“x64/Debug/alignedTypes.lastbuildstate”执行 Touch 任务。144&gt;144&gt;生成成功。144&gt;144&gt;已用时间 00:01:07.49========== 生成: 成功 134 个，失败 10 个，最新 0 个，跳过 0 个 ========== 结束Build后，就会在对应的目录中找到deviceQuery.exe了，在命令行中运行这个程序，会得到如下的结果： 123456789101112131415161718192021222324252627282930313233343536373839404142deviceQuery.exe Starting... CUDA Device Query (Runtime API) version (CUDART static linking)Detected 1 CUDA Capable device(s)Device 0: \"GeForce GT 755M\" CUDA Driver Version / Runtime Version 7.0 / 7.0 CUDA Capability Major/Minor version number: 3.0 Total amount of global memory: 2048 MBytes (2147483648 bytes) ( 2) Multiprocessors, (192) CUDA Cores/MP: 384 CUDA Cores GPU Max Clock rate: 1020 MHz (1.02 GHz) Memory Clock rate: 2700 Mhz Memory Bus Width: 128-bit L2 Cache Size: 262144 bytes Maximum Texture Dimension Size (x,y,z) 1D=(65536), 2D=(65536, 65536),3D=(4096, 4096, 4096) Maximum Layered 1D Texture Size, (num) layers 1D=(16384), 2048 layers Maximum Layered 2D Texture Size, (num) layers 2D=(16384, 16384), 2048 layers Total amount of constant memory: 65536 bytes Total amount of shared memory per block: 49152 bytes Total number of registers available per block: 65536 Warp size: 32 Maximum number of threads per multiprocessor: 2048 Maximum number of threads per block: 1024 Max dimension size of a thread block (x,y,z): (1024, 1024, 64) Max dimension size of a grid size (x,y,z): (2147483647, 65535, 65535) Maximum memory pitch: 2147483647 bytes Texture alignment: 512 bytes Concurrent copy and kernel execution: Yes with 1 copy engine(s) Run time limit on kernels: Yes Integrated GPU sharing Host Memory: No Support host page-locked memory mapping: Yes Alignment requirement for Surfaces: Yes Device has ECC support: Disabled CUDA Device Driver Mode (TCC or WDDM): WDDM (Windows Display Driver Model) Device supports Unified Addressing (UVA): Yes Device PCI Domain ID / Bus ID / location ID: 0 / 1 / 0 Compute Mode: &lt; Default (multiple host threads can use ::cudaSetDevice() with device simultaneously) &gt;deviceQuery, CUDA Driver = CUDART, CUDA Driver Version = 7.0, CUDA Runtime Version = 7.0, NumDevs = 1, Device0 = GeForce GT 755MResult = PASS 写一个小程序 在Visual Studio 2010 中新建一个空项目 添加新建项 在新建项对话框窗口左侧，选择NVIDIA CUDA7.0—Code 在右侧的列表框中选择CUDA C/C++ File,名字任意，不过最好选择一个有意义的名字 右键工程名字，选择生成自定义，在CUDA7.0项前的复选框，选中 右键新建的CUDA文件，后缀名是.cu，选择属性，将常规项中的，项类型修改为CUDA C/C++ 又将工程名字，选择属性，选择链接器 : 打开常规，编辑附加目录，添加内容 $(CUDA_PATH_V7_0)\\lib\\$(Platform) ; 打开输入，编辑附加依赖项，添加内容 cudart.lib 在CUDA文件中添加以下测试代码： 123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt; stdio.h&gt; #include \"cuda_runtime.h\" #include \"device_launch_parameters.h\" bool InitCUDA() &#123; int count; cudaGetDeviceCount(&amp;count); if(count == 0) &#123; fprintf(stderr, \"There is no device.\\n\"); return false; &#125; int i; for(i = 0; i &lt; count; i++) &#123; cudaDeviceProp prop; if(cudaGetDeviceProperties(&amp;prop, i) == cudaSuccess) &#123; if(prop.major &gt;= 1) break; &#125; &#125; if(i == count) &#123; fprintf(stderr, \"There is no device supporting CUDA 1.x.\\n\"); return false; &#125; cudaSetDevice(i); return true; &#125; int main() &#123; if(!InitCUDA()) return 0; printf(\"Hello World, CUDA has been initialized.\\n\"); getchar(); return 0; &#125; 若设备没有问题的话，正确的输出结果是： 1Hello World, CUDA has been initialized. 参考链接 win7+ VS2010安装CUDA7.0图文说明 windows7 64位机上CUDA7.0配置及在VS2010中的简单使用举例—语法高亮等 CUDA学习日志：windows开发环境配置— 推酷 NVIDIA GPU支持列表 Windows 下CUDA 开发环境安装及配置步骤 NVIDIA CUDA 在线课程 CUDA学习入门 — 博客园 NVIDIA CUDA Getting Started Guide for Microsoft Windows NVIDIA CUDA ZONE NVIDIA Geforce 755m支持CUDA—百度知道","tags":[{"name":"Cuda","slug":"Cuda","permalink":"http://yoursite.com/tags/Cuda/"},{"name":"Visual Studio","slug":"Visual-Studio","permalink":"http://yoursite.com/tags/Visual-Studio/"},{"name":"Win8.1","slug":"Win8-1","permalink":"http://yoursite.com/tags/Win8-1/"}]},{"title":"《深入探索C++对象模型》第四章读书笔记","date":"2015-06-07T15:07:41.000Z","path":"2015/06/07/read-the-semantics-of-function/","text":"","tags":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"},{"name":"对象模型","slug":"对象模型","permalink":"http://yoursite.com/tags/对象模型/"}]},{"title":"实习面试 三","date":"2015-06-02T12:54:59.000Z","path":"2015/06/02/interview-no-3/","text":"春季开学以来，跟随大流，准备找一份实习工作，攒攒经验，顺便犒劳一下钱包，虽然不是什么大牛级别的人物，但是我对编程还是比较热爱，而且很有钻劲儿，有志于在IT行业有所建树。根据自己的情况，整理了一份简历，还算过的去，至少是通过了B（百度）A（阿里巴巴）T（腾讯）的筛选，由于不同的原因，三个公司都没去成，不过还是攒下了经验，记录下来，为秋季找工作铺垫。 前面已经有了两次面试，这是第三次了，等写完论文把前面的两次面经补上。 出于保密，还是隐去面试企业的信息，只关注我的解题思路。 这次面试的公司虽然不是BAT这样的比较火爆的单位，但是这个单位是我非常尊重的，所以我非常看重，真的非常希望能够进入这家单位实习，更希望毕业能够签这家单位，所有我需要再继续认真努力给自己充电。 隐去了单位的信息，我只谈面试题目，也给出我的想法。 面试题目一 手写算法给一个数组（递增）、一个关键值，找到第一个比关键值大的元素的下标。考察的应该是二分查找，不过要稍微复杂一下，我当时忽略了有重复元素的特殊情况，写出的程序有些问题，提示用递归可能会好一些？我想也是，可是，递归结束条件是什么？面试官给的函数参数列表需要修改一下，干脆我就自己写了一个程序。刚才试了一下这个程序，还是真不好写，因为递归结束是个什么不好确定，还有就是边界检查问题。 1234567891011121314151617181920212223242526272829#include &lt;iostream&gt;using namespace std;int func(int arr[],int low,int high,int key,int start,int end)&#123; if(low &gt; high) &#123; if(key &lt; arr[low] &amp;&amp; low &lt;= end &amp;&amp; low &gt;= start) return low; else return -1; &#125; int mid = (low + high) / 2; if(arr[mid] &lt;= key) return func(arr,mid+1,high,key,start,end); else return func(arr,low,mid-1,key,start,end);&#125;int main()&#123; int arr[]= &#123;1,1,2,3,4,5,6,6&#125;; int key = 1; int t = func(arr,0,sizeof(arr)/sizeof(arr[0])-1,key,0,7); cout&lt;&lt;t&lt;&lt;endl; return 0;&#125; 有两点问题：递归结束条件，其实按照这个程序的逻辑，mid+1或者mid-1，只有一个边界移动，所有肯定出现low==high的情况，若把这个条件作为递归结束条件，那么确定结果就要分为两种情况： 第一，mid+1引起的low==high，也就是说mid位置的元素是==或者&lt;关键字的值的，所以新的搜索范围的左边界应该是mid+1，那么此时low==high，那么high位置的元素一定是结果吗？high是也是由mid-1得到的，从程序中的条件可以看出，这个mid位置的元素的，必然是&gt;关键字的值的，所以新的搜索范围的有边界应该是mid-1，这里是不能保证新的high位置的元素值&gt;关键字的值的，但是经过了若干次递归，high还没有变，且low==high了，那么此时可以确定high和low位置的元素小于等于关键字的值，并且high+1这个位置的原始是第一个大于关键字的，那么答案应该是high+1，那么返回high+1？那要low==high是由另外一种情况引起的呢？ 第二，mid-1引起的low==high，同样可以分析，mid位置的元素一定是&gt;关键字的值的，所以此时新的搜索范围的有边界应该是mid-1，结果导致low==high，那么low一定是结果吗？再考虑low是怎么得来的，low=mid+1，从程序中可以看出，这里的mid位置的元素的值是&lt;=关键字的值，这里不能保证mid+1位置的元素值一定是&gt;关键字的值的，但是经过若干次递归，low=mid+1的位置一直没变，并且已经到了low==high，那么此时可以确定low或者high位置的元素一定是第一个大于关键字值的元素，也就是此时应该返回low。 再分析两种low==high情况，如果，以low==high为递归退出的条件，那么就必须在里面判断了，第一种情况返回的是high+1，第二种情况返回的是high，不太容易判断；那么再让一点，让low&gt;high，第一种情况是low的位置元素是小于等于关键字的值，再一次递归，就是mid+1，也是low+1，此时low的位置正好是要找的位置。第二种情况，low位置的元素是第一个大于关键字的，再一次递归，也就是mid-1，也是high-1，此时low的位置是要找的位置，所以用low&gt;high作为递归结束条件比较方便。同时还能避免左侧越界问题，对于右侧越界问题，只能靠判断条件了。 越界，给参数列表添加数组左右边界，因为只会出现右越界，所以只判断右侧即可。 其实理解了这个思路，我感觉非递归的方式更好些。下面是非递归的代码，验证过，一样的。123456789101112131415161718int func(int arr[],int key,int len)&#123; int low,high; low = 0; high = len-1; while(low &lt;= high) &#123; int mid = (low + high) / 2; if(arr[mid] &lt;= key) low = mid +1; else high = mid -1; &#125; if(low &lt;len) return low; else return -1;&#125; 面试题目二 手写算法第二题相对简单一点，给定一个数组，每个数组代表一个间隔的高度，每个间隔的宽度都是一样的,都是1，所有间隔的长也是1，下雨后，两个高的间隔就有水，求下雨后累积水的最大的体积是多少？ 我听到这一题的最直接的想法是用栈来实现，因为这个题目跟那个直方图最大矩形面积有些相似。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647int func2(int arr[],int len)&#123; stack&lt;int&gt; s; bool flag = false; int left=0; int sum =0; for(int i=0;i&lt;len;++i) &#123; if(!flag) &#123; if(s.empty()) &#123; s.push(arr[i]); &#125; else &#123; if(s.top() &gt; arr[i]) &#123; flag = true; left = s.top(); s.push(arr[i]); &#125; else &#123; s.pop(); s.push(arr[i]); &#125; &#125; &#125; else &#123; if(left &gt; arr[i]) s.push(arr[i]); else &#123; while(!s.empty()) &#123; sum += left - s.top(); s.pop(); &#125; flag = false; s.push(arr[i]); &#125; &#125; &#125; return sum;&#125; 最后感觉没有把自己的实力展现出来，希望进入面试。","tags":[{"name":"实习","slug":"实习","permalink":"http://yoursite.com/tags/实习/"},{"name":"面试","slug":"面试","permalink":"http://yoursite.com/tags/面试/"}]},{"title":"《深入探索C++对象模型》第三章读书笔记","date":"2015-05-18T15:40:01.000Z","path":"2015/05/18/read-the-semantics-of-data/","text":"@(Cplusplus)相对于前一章的内容，这一章还是比较晦涩，不是内容难，而是这里面这几不同的编译器，不同版本的编译，对程序的理解和编译结果有差异，差异多了自然就记不住了，所以，这一章我认真的看了两遍，并且xmind画了思维导图。 导读每一章都有一些篇幅是导读内容，用来介绍这章要讲的是什么。这章的导读比较有意思，不是说特别有趣，而是用程序写出来很容易验证，并且记住这段内容。给出的代码是这样的：1234class X&#123;&#125;;class Y:public virtual X&#123;&#125;;class Z:public virtual X&#123;&#125;;class A:public Y,public Z&#123;&#125;; 在主函数中可以输出并验证一下：12345678X x; Y y; Z z; A a; cout&lt;&lt; sizeof x&lt;&lt;endl; cout&lt;&lt;sizeof y&lt;&lt;endl; cout&lt;&lt;sizeof z&lt;&lt;endl; cout&lt;&lt;sizeof a&lt;&lt;endl; 我是在window环境下测试的，两种编译器：Visual Studio 和Windows版本的gcc — MinGW。运算结果都是一样的：12341448 这个导读其实我比较关注三个问题： 空的类的对象大小到底是多少？答案是1，这个空间是编译器安插进去的一个字节的空间，用来区分这个类的不同的对象。（后面会有彩蛋） 类Y和Z的对象的大小是多少呢？同样，这两个类也没有数据成员，当前我的编译器给出的都是4，这个四个字节存放的是个什么鬼？我是编译的32位程序，地址也就是32位，这4个字节存放的是指针，因为是虚继承，所以，这个指针指向的是虚基类子对象的地址，（若是多个虚继承，就指向一个表格，表格存放所有虚基类子对象的地址或者是偏移量） 对齐（Alignment）限制，32位的应用程序的对齐大小是4个字节，也就是说若一个类的对象的字节数若不是4的整数倍，需要补齐，这是为了方便处理器进行计算。 彩蛋呢？既然不是4的整数倍就要对齐，那么空类的对象为什么不补齐？我感觉书上给出的有点迷惑，书中原话是对于空类的对象: 编译器要安插一个char 我理解的是这里不应该说是一个char，应该是一个字节的空间，不知道是个什么东西，就是用来占据内存的一个空间，这样，空类类型的指针也可以指向内存中一个位置（就是这个一个字节，不存储任何数据），同时，同一个类的不同对象由于分配不同的一个字节的空间，也就能区分不同的对象了。我是这样理解的。 书上来信者的编译器给出的答案是1 8 8 12，这里的8=1+4+3，其中4是指向基类子对象的指针，3是对齐产生的，1是因为父类为空，编译器给了它一个字节的空间。是从父类继承而来的。其实我认为这样解释不妥，一个字节的空间实际是在创建对象的时候分配的，并不是类本身具有的，我认为这里的1个字节的空间也是因为类Y和Z是空类，所以编译器也给他们添加了一个字节的空间。其实作者在86页的解释也应该是证明这一点的。我身边没有这样的编译器，否则我应该做一个实验验证一下。 现代的编译器采用了一种新的策略：它将空的虚基类作看作是一个虚接口（virtual interface），空的虚基类视为其派生类的一部分（最开始的部分），这样派生类里面指向虚基类子对象的指针就被视为派生类的第一个成员了，而且这是一个数据成员，以前则是把虚继承当作是一种额外的负担，编译器自动处理这种负担，就是给每个对象添加一个指针。那么既然现在这个指针是派生类的成员了，派生类数据成员不为空了，所以，也就没有编译器安插的一个字节空间了，所以派生类对象大小是4. 上次写到这里！今天开题答辩，挺累的，还是写点吧 至于最后一个对象的大小，是12，书中的解释是因为共享了虚基类的一个字节，其实，我还是认为这个一个字节不是在虚基类添加的，而是虚基类对象添加的（用来区分不同的对象）。我的解释是这里之所以是12，是因为编译器还没有优化，没有将指向虚基类对象的指针看作是派生类的一部分，因此派生类也是空类，编译器需要给他们一个字节的空间，这样，继承了两个这样的类的A，就需要(4+1)*2空间，在由编译器进行对齐，就变成了12字节。 对于优化了的编译器，为什么是8？原因是指向虚基类的指针被当作成员了，那么派生类就不是空类了，他们的对象的空间大小是4，两个相加就是8咯！ 我觉得我的解释还是比较有道理，但是没有这样的编译器，也就不好验证，而且目前都是优化了的，也就没有太大意义去钻这个牛角尖了。 临时插一句话，这本书讲的还是比较有深度的，今天身体实在是不舒服，而且要回宿舍洗澡，这一章的内容还是差一些才能看完，预计还需要一到两天，而且白天我要写论文。 数据成员的绑定这一小节的内容还是比较晦涩的，原因是没办法验证。而且我不知道这个对我的帮助有多大，我还是不了解这条规则的意义。 接着写 数据成员的布局这一节主要介绍了对象在内存的布局，对象只存储非静态的数据成员，多个数据成员的排列是相对有序的，按其声明的顺序排列，但是不一定shiite连续的，中间也许会存取一些别的东西，比如：指向虚函数表的指针、边界补齐的对齐字节。另外，在C++中有访问控制符，每种访问控制符access section可以出现多次，但是不会带来额外的负担。 这一节的内容就是这么少，其实用图形可能描述的更好。 数据成员的存取这一节比较有意思，用一个例子引起的，其实整节内用就可以用这个例子来描述。 1234Point3d origin,*pt = &amp;origin;// 以下两种访问方式有什么不同origin.x = 0;pt-&gt;x = 0; 例子中给出的非静态数据成员的访问。非静态数据类型存储在对象中，因此只能通过对象或者对象的指针访问非静态数据类型。 非静态数据类型的地址，是对象的地址添加上数据成员的了偏移（offset），这里的偏移是要减去一个1的，这一点在后面会讲到，我这里提前说了。 这里提到的偏移实际上是数据成员的指针（data member指针），与普通的指针不同，这个对象指针是相对于对象的地址，也就是这个数据成员的偏移地址。 指针可以指向空，数据成员指针也是一样的，这里为了区分数据成员的指针是指向第一个成员（第一个成员的偏移地址是0），还是什么都没指向（通常设为0），就把指向成员的数据成员指针加1，实际使用的时候再减1. 数据成员的地址定义如下：Point3d::*。一个成员的成员指针是&amp;Point3d::y。可以通过&amp;origin + (&amp;Point3d::y -1)获取数据成员的地址。 每个数据成员的偏移地址，也就是数据成员指针一般是在编译时期就可以获得的。所以这样的情况下，用对象访问数据成员和用指针访问数据成员代价是一样的。但是当出现了虚基类，存取是虚基类的数据成员，那就不一样了，因为指针不一定是指向的哪一个类类型，在编译的时候就不能计算出数据成员的偏移量，偏移量的计算会推迟到执行阶段。所以，这种情况下使用类的对象访问数据成员与指针访问数据成员速度不一样，指针是要慢的。 “继承”与数据成员这一节就是把多种情况介绍了一下，其实也没啥，单一继承没什么，多继承也没什么，有虚函数就是多了一个指向虚表的指针，最麻烦就是有虚基类的，这时候就要分为共享部分和不变部分，所谓的共享部分就是指的虚基类的子对象，所有派生类的对象都只有一个虚基类的子对象实例。关键点是这个共享部分怎么找到。 对象成员的效率这节没啥意思，就是讲的添加封装，多态等特征后，相对于直接访问，C语言结构体访问，访问代价，但是编译器添加了优化，几乎都是一样的了。 指向对象成员的指针这个刚才介绍了，就是相对于对象的指针，也就是偏移，为了区分没有指向数据成员的指针和指向数据成员的指针，数据成员指针都要加1. 总结这一章的内容就是这些，不是很多，但是需要记忆的挺多的，有些技巧还是需要理解，比如在面试的时候如何访问一个对象的私有成员，应该回答是用指针，但是如果把数据成员指针也给解释一通，那就更好不过了。","tags":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"},{"name":"对象模型","slug":"对象模型","permalink":"http://yoursite.com/tags/对象模型/"}]},{"title":"《C陷阱和缺陷》读后感","date":"2015-05-17T14:55:52.000Z","path":"2015/05/17/read-c-traps-and-pitfalls/","text":"@(zhangxiaoya89的笔记本) 这篇笔记就起这么一个俗气的名字吧，《C陷阱和缺陷》这本书是去年买的，但是去年没有完全看完，只是看了前半部分，昨天才想起来，找出来，翻了翻发现没剩下多少了于是就打算昨天看完，但是昨天看另外一片文章入迷了，就没时间再继续完成这个了，刚刚吃过饭没事就把剩余的部分看完了，感觉没有去年那种神秘了。刚刚看完，给我的感觉就是这本书在用一种大师的口气来教训我在学习和使用C语言编写程序过程中应该或者必须要注意的问题。也就是像书的封面写的“聆听大师的教诲，掌握编程精髓”。 从这本书中能学到什么？虽然是刚刚看完书的后半部分，但是大半的内容已经忘记了，因为有些东西我并不打算现在就很认真的关系，至少是现在，当下我最主要的任务就是尽可能高效的掌握C语言和C++的比较基本，而且是实际工程项目广泛应用的知识，另外还有应对面试官那些我忽略的问题，比如虚函数实现机制、宏是个什么鬼。。。此类问题。对于平台移植相关，以及早期机器（16位机器、甚至是8位机器）我暂时不想化太多的时间仔细研究。那就列举我在这本书中学到的东西把。 这本书的是想说什么？有意思的是，这本书是从第0章开始，比较符合C语言的风格，哈哈。。。至少我是这样理解的。这一章节介绍了这本书要写的是什么东西。文中的一句话我感觉定位还是比较准确的： 程序设计错误实际上是反映的程序与成员对该程序的”心智模式“两者的相异之处。 这本书要介绍的内容是我们在使用C语言时常犯的错误，引起这些错误的原因来自两部分：程序语言本身的缺陷和程序语言中不容易注意的错误。这类的错误区别与通常由程序员逻辑思维造成的错误，换句话说，本书中讲到的错误通常不是程序员故意要犯的错误。就像上面的那句话，这类错误是程序语言对程序的理解和程序员对程序的理解不一样造成的。我们可以把这类的错误当做是程序语言的缺陷，或者是故意留下的陷阱。程序设计语言是分为若干个层次的： 从词法分析的角度，也就是从每个符号token的角度分析错误； 从语法分析的角度，也就是从每个语句的角度分析； 从语义分析的角度，也就是对于每个语句完成的任务的具体的意义角度分析； 通过了编译的阶段，下一个阶段就要分析在链接阶段会有哪些容易被忽略的错误； 程序设计语言都提供了很方便的调用库，在使用不同的库函数的时候又会发生哪些错误。 预处理这个过程也不能忽略，著名的宏就是在这个阶段起作用的，这个阶段有什么陷阱。 习惯了使用高级开发语言，语言本身提供了可移植属性，那么对于C语言是不能忽略程序移植遇到的问题。 以上阶段也就是包含了在程序设计过程中所有出现错误的不同层次，从这些层次依次逐个分析，就把这些陷阱或者缺陷都揪出来了。 这也就是这本书的意义，不是分析程序员的逻辑错误，而是程序员容易忽略的问题，或者由于程序语言设计的缺陷会带来的潜在问题。若是这个目的，那么就可以很顺利的读完这本书，并且收货还是不少。 “词法”到底会有什么trap单词或者是符号token对于编译器来说已经是原子了，这里能有什么错误，除非是把符号都写错了，还是真有一些，前辈还是列举了几个： 符号，比如说判断相等的符号“==”，容易少些一个； 符号&amp;和符号&amp;&amp;是不同的； 数字我们默认是十进制，但是当一个整数是0开始的，那它就是八进制了； 字符串与字符的区别，一个是单引号，一个是双引号，能区分吗？ 也就这点东西了，如果陷阱再多一点，我就怀疑语言本身的问题了。 ”语法“能有什么问题呢？这一章是我最认真阅读的，也是我发现我也有好多问题没有想过，这些错误确实是我的弱点。 函数指针是个什么鬼？就是一个指针，指向某个类型的函数的首地址。像其他指针一样，可以进行强制转化，地址为0的函数能用吗？我怕把自己的系统挂了。。。 运算符的优先级，我其实最讨厌这个，经常记混了，赋值运算符assignments居然是从右向左结合，这个一定要记住了；还有sizeof不是一个函数，他是运算符，后面可以不用写括号的。 分号表示已经结束了，一定不要忘了，尤其是跟return在一起的时候。 switch语句经常忘记break，这个通常编译器是允许的，但是运行结果可能大相径庭。 函数调用在函数名后面要由括号包含实参列表的，即使没有实参，也要有括号； 悬挂else，通常else要跟同意括号内最近的未匹配的if结合的，这里最好是按照正确的格式写代码，就算它什么也不做，那就加上一个分号而已。 在“语法”上常常忽视的问题 数组与指针，一位数组问题不是特别大，注意指针是指针，数组虽然是指向首元素的指针，但是它也只是数组名而已；最应该要注意的是二维数组与二级指针，定义一个指向一个数组的指针怎么定义？int (*p)[31];这里的*p实际上是一个有31个元素的数组；当然，也可以从第二维定义，先定义一个指针数组，int ** pp = int *[12];，然后给每个数组分配空间。 非数组的指针，使用前一定要分配空间哦。 作为参数的数组声明，数组名会退化成指针的。 避免“举隅法”（synecdoche）这个词的意思是用宽泛的意思代替较窄的词语，需要注意的是复制指针，病不能复制指针所指向的内容。 空指针并不等于空字符串，直接比较两个指针是可以的，但是不要用strcmp函数判断空指针，这个函数是要判断指针指向的内容的。 边界计算与不对称边界，这里讲的内容最多，其实就是讲的边界不对称的情况下方式数组越界，这个也是面试的时候经常会考到的问题。 求值顺序，这里其实就要注意自增或者自减的问题，还有在语句中，表达式的计算顺序。 运算符&amp;&amp;、||和！，这个问题比较常见。 整数溢出，也是面试的时候常常考虑到的，如何判断表达式是否越界，借助无符号数是个不错的方式，比如if(a &gt; INT_MAX - b) xxx;或者if((unsigned)a +(unsigned)b &gt; INT_MAX) xxx;. 给main函数提供一个返回值，这个我通常是返回0. 链接器也会出问题给我的感觉就是这章的内容给意义并不是特别大，主要介绍的是链接器在链接过程中如何处理外部变对象的命名冲突，所谓的外部对象是在函数体外声明或者定义的变量，这里的内容在《程序员的自我修养—编译、链接与库》介绍的比较详细了。 正确使用库函数库函数确实很方便，但是使用不好也容易出错，这章的内容我感觉意义不大，至少对我现在的任务来说，重点不在这里。 预处理这个比较重要，因为预处理主要是处理宏，这个东西比较诡异，因为是在预处理阶段，是不能检测到任何语言级别的错误的，语言级别的错误只有编译器和连接器才能检测到，预处理只是在文本上进行处理，比如去掉所有的注释，将所有的宏展开，这里的展开是指在任何使用宏的地方将程序文本替换，并不检查什么 语法错误。用宏定义常量还是没问题的，但是： 不能忽略宏中的空格 宏不是函数，不要没事把函数定义成宏 宏也不是语句 宏也不是类型 最后，最好是少用宏，用常量吧！ 移植问题我暂时不想考虑！ 最后，前辈给出建议就是不要说服自己皇帝的新装；在程序中明确的表明自己的意图。总结程序一句话：写程序别装X！","tags":[{"name":"C语言","slug":"C语言","permalink":"http://yoursite.com/tags/C语言/"},{"name":"读后感","slug":"读后感","permalink":"http://yoursite.com/tags/读后感/"}]},{"title":"实现STL中的next_permutation函数","date":"2015-05-16T08:05:47.000Z","path":"2015/05/16/my-next-permutation/","text":"@(C Plus Plus) 前几天复习一份各大公司的面试笔试资料—题目是《百度、google、微软、MTK经典面试题》，应该是我在考研的时候看过的，为了准备机试，北理工13年计算机学院的硕士生保研题目就有一个是输出一个字符串的全排列。这个题目以前是没见过，所以仔细的研究了一下. 那就还是从这个题目开始： 输出一个字符串的全排列 注意的是，这个题目没有要求按照字典序输出，只要输出所有的排列就行。 STL 函数 next_permutation()第一种比较容易的方式就是利用STL里面的函数next_oermutation()，这个函数的返回值是bool类型，若按照字典序，字符串还有下一个排列，就改变字符串为下一个排列，并返回true，否则返回false，并且将字符串重置为初始状态。程序如下：1234567891011void printAllPermutation(char *str)&#123; int len = strlen(str); char *pend = str + len; std::sort(str,pend); std::cout&lt;&lt;str&lt;&lt;std::endl; while(std::next_permutation(str,pend)) &#123; std::cout&lt;&lt;str&lt;&lt;std::endl; &#125;&#125; 交换的策略这个算法我一直没真正理解是真么意思，它的基本思想是交换-恢复，遍历所有两个位置的组合，它是无序的，具体的程序如下：12345678910111213141516171819void swap(char *a,char *b)&#123; char t = *a; *a = *b; *b = t;&#125;void printAllPermutation(char *str,char *pbeg)&#123; if(str == NULL) return; if(*pbeg == '\\0') std::cout&lt;&lt;str&lt;&lt;std::endl; for(char *p = pbeg;*p != '\\0';++p) &#123; swap(p,pbeg); printAllPermutation(str,pbeg+1); swap(p,pbeg); &#125;&#125; 实现next_permutation()函数这是前几天在网上找到的，还是网易2014年实习生笔试题目，作者的思路不错，但是就是没有描述清楚。我来试着描述一下他的思想： 假设当前序列是13542，那么我们可以手动计算出下一个序列是14235； 这个题目的关键点是寻找一个关键位置，观测发现，这样的字符串通过有个性质，其中一个位置，将字符串分成两部分，前半部分没什么规律，后半部分递减（可以为空）。 寻找下一个排列就是，找到这样的一个位置，这个位置以后的字符串是递减的，也就是说后半部分已经没有下一个排列了（下一个排列回归到初始状态），从后半部分找到第一个（从后往前找）比当前位置大的字符，然后交换。 比如上面的例子，关键位置的元素是3，后半部分第一个比3大的元素是4，交换顺序后字符串是14532，当关键位置变大时，其后面的子字符串应该是第一个排列，也就是递增的，因此，下一步就是将后半部分反转（交换后也是递减的，因此直接反转就是递增的），得到字符串是14235。 下面是程序实现：12345678910111213141516171819bool mynext_permutation(char *beg,char *end)&#123; if(beg == NULL || strlen(beg) == 0) return false; char *k = end -2; while(*k &gt; *(k+1)) --k; if(k &lt; beg ) // 字符串已经逆序，最后一个排列 &#123; reverse(beg,end); return false; &#125; char *p = end -1; while(*p &lt; *k) --p; swap(p,k); reverse(k+1,end); return true;&#125; 为了验证，给出测试程序：1234567891011121314int main()&#123; char str1[] = \"1234\"; char str2[] = \"1234\"; cout&lt;&lt;str1&lt;&lt;endl; cout&lt;&lt;str2&lt;&lt;endl&lt;&lt;endl; while(mynext_permutation(str1)) &#123; std::next_permutation(str2,str2 + strlen(str2)); cout&lt;&lt;str2&lt;&lt;endl; cout&lt;&lt;str2&lt;&lt;endl&lt;&lt;endl; &#125; return 0;&#125; 重新实现库函数貌似是面试笔试常考的，就以这个为开始吧，以后继续写写！ 参考网易有道笔试题(2014届，2013.10北邮站)百度、谷歌、微软、MTK经典面试题","tags":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"},{"name":"STL","slug":"STL","permalink":"http://yoursite.com/tags/STL/"},{"name":"全排列","slug":"全排列","permalink":"http://yoursite.com/tags/全排列/"},{"name":"实现库函数","slug":"实现库函数","permalink":"http://yoursite.com/tags/实现库函数/"}]},{"title":"C++中的多线程","date":"2015-05-16T01:49:26.000Z","path":"2015/05/16/multi-thread-in-Cplusplus/","text":"@(C Plus Plus) 多线程的概念在操作系统里面有详细的介绍，这里就不浪费时间了。具体的介绍一下C++编程语言里的多线程编程。在有些编程语言中，对多线程或者并发的支持是直接内建在语言中，比如Ada和VHDL，但是在C++里面，对多线程的支持是由具体的操作系统提供的函数接口来支持的，不同的操作系统具体实现方法不同。 前面的一篇文章（Linux下多线程（C语言））介绍了如何在Linux下进行多线程编程，Linux环境下的多线程编程是基于pthread，遵循POSIX线程接口，需要使用pthread.h头文件，链接的时候需要使用库libpthread.a，是用过clone()实现的，类似于fork()。这篇文章介绍一下在Windows下多线程编程的基本知识。 进程的创建线程的状态在一个线程的生存周期内，存在多种县城的状态，但是基于不同的操作系统平台，也有不同的线程模型，定义的线程的状态也有不同，但是总体来说，线程的几种状态还是比较通用的： 就绪：参与调度，等待执行，一旦获取CPU使用权，立即执行； 运行：使用CPU，正在运行； 休眠：暂不参加调度，等待需要的资源满足后，触发事件进入就绪状态； 终止：线程运行结束，等待回收线程资源。 线程的资源线程存在于进程中，进程中所有的资源对于进程内部的线程都是可见的，进程中典型的资源如下： 代码区：进程内部的代码对于每个线程都是可见的，代码区只有一份实体； 静态存储区： 全局变量： 静态变量： 动态存储区： 线程内部的资源有： 本地栈空间：存放本线程的函数调用栈，函数内部变量； 部分寄存器： 主线程与从线程一个进程开始运行后，就会产生一个缺省的线程，通常这个线程为主线程。C++程序中主线程就是通过main函数进入线程，由主线程衍生的线程称作是从线程，从线程也有自己的函数入口，作用类似于main函数。对于普通的线程模型，主线程比较特殊，它与其他线程之间是父子线程的关系，但是从线程之间是对等关系（peer to peer），不存在隐含的层次关系。 线程的入口函数线程都有自己的入口函数，pthread和winapi都是使用函数指针的方式传递入口函数，同时也可以指定函数的参数，但是函数的参数都是void *类型，pthread的返回类型是void *类型，winapi的函数返回类型是unsigned int类型，线程的入口函数是全局函数。 Windows下多线程编程创建多线程Windows SDK提供了创建进程的函数CreateThread()，该函数的定义如下： 12345678HANDLE CreateThread( LPSECURITY_ATTRIBUTES lpsa, DWORD cbStack, LPTHREAD_START_ROUTINE lpStartAddr, LPVOID lpvThreadParam, DWORD fdwCreate, LPDWORD lpIDThread); 参数简介： LPSECURITY_ATTRIBUTES lpsa是安全树形结构体，主要控制该线程的句柄可否为进程的子进程继承使用，默认使用NULL表示不能继承；若想继承线程句柄，则需要设置改结构体，将结构体的bInheritHandle成员初始化为TRUE； DWORD cbStack表示线程初始栈的大小，若是0表示采用默认大小初始化； LPTHREAD_START_ROUTINE lpStartAddr表示线程开始的位置，即函数入口位置； LPVOID lpvThreadParam用来接收线程过程函数的参数，不需要时可以设置为NULL； DWORD fdwCreate表示线程创建时的标志，CREATE_SUSPENDED表示线程创建后挂起暂不执行，必须调用ResumeThread才可以执行，0表示线程创建后立即执行； LPDWORD lpIDThread保存线程的ID 下面一个简单的程序来演示Windows下多线程编程：12345678910111213141516171819202122232425262728293031#include &lt;iostream&gt;#include &lt;cstdlib&gt;#include &lt;windows.h&gt;using namespace std;DWORD WINAPI FunProc(LPVOID lpParam);int main()&#123; int j = 0; HANDLE hThread1 = CreateThread(NULL, 0, FunProc, NULL, 0, NULL); CloseHandle(hThread1); while(j++ &lt; 100) cout&lt;&lt;\" Main Thread is running for \"&lt;&lt;\"the \"&lt;&lt;j&lt;&lt;\" times \"&lt;&lt;endl; system(\"pause\"); return 0;&#125;DWORD WINAPI FunProc(LPVOID lpParam)&#123; int i = 0; while(i++ &lt; 100) cout&lt;&lt;\" Thread 1 is running for \"&lt;&lt;\"the \"&lt;&lt;i&lt;&lt;\" times \"&lt;&lt;endl; return 0;&#125; 互斥信号量多线程编程避免不了访问临界区的问题，创建互斥量的函数的定义如下： 12345HANDLE CreateMutex( LPSECURITY_ATTRIBUTES lpMutexAttributes, BOOL bInitialOwner, LPCTSTR lpName); 参数简介： LPSECURITY_ATTRIBUTES lpMutexAttributes与前面的一样，是安全结构体，默认是NULL； BOOL bInitialOwner其值为FALSE表示创建Mutex，不指定所有权，其值为TRUE，指定当前创建进程的ID为所有者，其他线程访问需要先ReleaseMutex LPCTSTR lpName表示用于设置Mutex的名字，为NULL时表示匿名互斥量。 使用互斥量的另外两个函数是：WaitForSingleObject()：请求一个互斥量的访问权；ReleaseMutex()：释放一个互斥量的访问权。 一个简单的应用程序：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include &lt;iostream&gt;#include &lt;cstdlib&gt;#include &lt;windows.h&gt;using namespace std;DWORD WINAPI Fun1Proc(LPVOID lpParam);DWORD WINAPI Fun2Proc(LPVOID lpParam);int tickets = 100;HANDLE hMutex;int main()&#123; int j = 0; hMutex = CreateMutex(NULL,FALSE,NULL); HANDLE hThread1 = CreateThread(NULL, 0, Fun1Proc, NULL, 0, NULL); HANDLE hThread2 = CreateThread(NULL, 0, Fun2Proc, NULL, 0, NULL); CloseHandle(hThread1); CloseHandle(hThread2); system(\"pause\"); return 0;&#125;DWORD WINAPI Fun1Proc(LPVOID lpParam)&#123; while(true) &#123; WaitForSingleObject(hMutex,INFINITE); if(tickets &gt; 0) &#123; Sleep(10); cout&lt;&lt;\"Thread 1 sell tickets : \"&lt;&lt;tickets--&lt;&lt;endl; &#125; else break; ReleaseMutex(hMutex); &#125; return 0;&#125;DWORD WINAPI Fun2Proc(LPVOID lpParam)&#123; while(true) &#123; WaitForSingleObject(hMutex,INFINITE); if(tickets &gt; 0) &#123; Sleep(10); cout&lt;&lt;\"Thread 2 sell tickets : \"&lt;&lt;tickets--&lt;&lt;endl; &#125; else break; ReleaseMutex(hMutex); &#125; return 0;&#125; 参考Windows线程函数概述 - 《C++编程艺术》秒杀多线程系列","tags":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"},{"name":"Windows","slug":"Windows","permalink":"http://yoursite.com/tags/Windows/"},{"name":"多线程","slug":"多线程","permalink":"http://yoursite.com/tags/多线程/"}]},{"title":"Linux 下多线程（C语言）","date":"2015-05-15T10:59:28.000Z","path":"2015/05/15/multi-thread-of-c-program-language-on-linux/","text":"@(C Plus Plus) 经过前两次面试，发现多线程成了面试官的必选，要么让写一个pthread的程序，要么写一个读者写者问题的伪代码，好久没复习了，先把Linux下多线程的东西复习一下。 简介 进程— 资源分配的最小单位线程— 程序执行的最小单位 进程是一个程序的一个实例，拥有自己独立的各种段（数据段，代码段等等），每次创建一个进程需要从操作系统分配这些资源给他，消耗一定的时间，在linux下C语言创建一个进程使用fork()函数；线程是一个轻量级的进程，除了自己少数的资源，不用用其他资源，且一个进程可以创建多个线程，这些线程共享进程的资源，创建线程的时间要比创建进程少很多，（几十分之一），从函数角度是使用clone()创建。使用线程处理文件I/O或者socket处理都是非常有优势的，将一个大人物分解成若干个小任务，每个线程处理一个任务，线程之间切换不需要花很多时间，而且线程之间数据交换很方便，共享存储区。 C语言中使用多线程的函数创建线程 int pthread_create(pthread_t * tid, const pthread_attr_t * attr, void * ( * func) (void * ), void * arg);其返回值是一个整数，若创建进程成功返回0，否则，返回其他错误代码，也是正整数。 创建线程需要的参数： 线程变量名：pthread_t *类型，是标示线程的id，一般是无符号整形，这里也可以是引用类型，目的是用于返回创建线程的ID 线程的属性指针：制定线程的属性，比如线程优先*级，初始栈大小等，通常情况使用的都是指针。 创建线程的程序代码：一般是函数指针，进程创建后执行该函数指针只想的函数。 程序代码的参数：若线程执行的函数包含由若干个参数，需要将这些参数封装成结构体，并传递给它指针。创建线程的函数的形式如下： 结束线程结束进程的函数定义如下： void pthread_exit (void *status);参数是指针类型，用于存储线程结束后返回状态。 线程等待 int pthread_join (pthread_t tid, void ** status); 第一个参数表示要等待的进程的id； 第二参数表示要等待的进程的返回状态，是个二级指针。 线程创建后怎么执行，新线程和老线程谁先执行这些不是程序来决定，而是由操作系统进行调度的，但是在编程的时候我们常常需要多个线程配合工作，比如在结束某个线程之前，需要等待另外一个线程的处理结果（返回状态等信息），这时候就需要使用线程等待函数，这个函数的定义如下： 其他关于进程的函数 返回当前线程ID pthread_t pthread_self (void);用于返回当前进程的ID 制定线程变成分裂状态 int pthread_detach (pthread_t tid);参数是指定线程的ID，指定的ID的线程变成分离状态；若指定线程是分离状态，则 如果线程退出，那么它所有的资源都将释放，如果线程不是分离状态，线程必须保留它的线程ID、退出状态，直到其他线程对他调用的pthread_join()函数 参考实例一代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;stdio.h&gt;#include &lt;pthread.h&gt;#include &lt;stdlib.h&gt;void print_message_func(void *ptr);int main()&#123; int tmp1,tmp2; void *retival; pthread_t thread1,thread2; char *message1 = \"thread1\"; char *message2 = \"thread2\"; int ret_thread1,ret_thread2; ret_thread1 = pthread_create(&amp;thread1,NULL,(void *)&amp;print_message_func,(void *)message1); ret_thread2 = pthread_create(&amp;thread2,NULL,(void *)&amp;print_message_func,(void *)message2); if(ret_thread1 == 0) printf(\"create thread 1 true\\n\"); else printf(\"create thread 1 false\\n\"); if(ret_thread2 == 0) printf(\"create thread 2 true\\n\"); else printf(\"create thread 2 false\\n\"); tmp1 = pthread_join(thread1,&amp;retival); printf(\"thread 1 return value (retival) is %d\\n\",(int)retival); printf(\"thread 1 return value (tmp1) is %d\\n\",tmp1); if(tmp1 != 0) printf(\"cannot join with thread 1\\n\"); printf(\"thread 1 is end\\n\"); tmp2 = pthread_join(thread2,&amp;retival); printf(\"thread 2 return value (retival) is %d\\n\",(int)retival); printf(\"thread 2 return value (tmp2) is %d\\n\",tmp2); if(tmp2 != 0) printf(\"cannot join with thread 2\\n\"); printf(\"thread 2 is end\\n\"); &#125;void print_message_func(void *ptr)&#123; for(int i=0;i&lt;5;++i) printf(\"%s:%d\\n\",(char*)ptr,i);&#125; 这个代码比较简单，就是演示这几个常用函数的使用。 这里是纯C语言程序，在Linux下的编译命令是gcc main.c -test -lpthread，运行程序是./test，后面的程序同样 多线程的同步与互斥锁机制多线程之间可能需要互斥的访问一些全局变量，这就需要互斥的来访问，这些需要共享访问的字段被称作是临界资源，访问临界资源的程序段称作是临界区。实现线程间的互斥与同步机制的是锁机制，下面是常用的锁机制的函数和类。 pthread_mutex_t mutex 锁对象 pthread_mutex_init(&amp;mutex,NULL) 在主线程中初始化锁为解锁状态 pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER 编译时初始化锁位解锁状态 pthread_mutex_lock(&amp;mutex): 访问临界区加锁操作 pthread_mutex_unlock(&amp;mutex): 访问临界区解锁操作 参考实例二（不加锁访问互斥全局变量）12345678910111213141516171819202122232425262728293031323334#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;pthread.h&gt;int sharei = 0;void increase_num(void);int main()&#123; int ret; pthread_t thread1,thread2,thread3; ret = pthread_create(&amp;thread1,NULL,(void *)&amp;increase_num,NULL); ret = pthread_create(&amp;thread2,NULL,(void *)&amp;increase_num,NULL); ret = pthread_create(&amp;thread3,NULL,(void *)&amp;increase_num,NULL); pthread_join(thread1,NULL); pthread_join(thread2,NULL); pthread_join(thread3,NULL); printf(\"sharei = %d\\n\",sharei); return 0;&#125;void increase_num(void)&#123; long i,tmp; for(i =0;i&lt;=10000;++i) &#123; tmp = sharei; tmp = tmp + 1; sharei = tmp; &#125;&#125; 编译运行结果，多运行几次，发现结果都不一样。这就是因为对于全局变量，没有添加互斥锁，导致的问题。 参考实例三 （访问全局变量添加互斥锁）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;pthread.h&gt;int sharei = 0;void increase_num(void);// add mutexpthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;int main()&#123; int ret; pthread_t thread1,thread2,thread3; ret = pthread_create(&amp;thread1,NULL,(void *)&amp;increase_num,NULL); ret = pthread_create(&amp;thread2,NULL,(void *)&amp;increase_num,NULL); ret = pthread_create(&amp;thread3,NULL,(void *)&amp;increase_num,NULL); pthread_join(thread1,NULL); pthread_join(thread2,NULL); pthread_join(thread3,NULL); printf(\"sharei = %d\\n\",sharei); return 0;&#125;void increase_num(void)&#123; long i,tmp; for(i =0;i&lt;=10000;++i) &#123; // lock if(pthread_mutex_lock(&amp;mutex) != 0) &#123; perror(\"pthread_mutex_lock\"); exit(EXIT_FAILURE); &#125; tmp = sharei; tmp = tmp + 1; sharei = tmp; // unlock if(pthread_mutex_unlock(&amp;mutex) != 0) &#123; perror(\"pthread_mutex_unlock\"); exit(EXIT_FAILURE); &#125; &#125;&#125; 添加互斥锁后，就发现，多次运行的结果都是一样的。 其实这里的加锁不是对共享变量（全局变量）或者共享内存进行保护，这里的加锁实际上是对临界区的控制，所谓的临界区就是访问临界资源的那一段代码，这段代码对临界资源进行多种操作，正确的情况是不允许这段代码执行到一半，处理器使用权就被其他线程抢走，所以这段代码具有原子性，即要么执行，要么不执行，不能执行到一半就被抢走处理权，这样就会造成共享数据被污染。 还有一点，添加锁来控制临界区是有代价的，这个代价表现出来就是时间的额外开销，内部过程是因为要保护现场，会利用一些资源，也需要处理器处理的时间。 信号量机制锁机制使用是有限制的，锁只有两种状态，即加锁和解锁，对于互斥的访问一个全局变量，这样的方式还可以对付，但是要是对于其他的临界资源，比如说多台打印机等，这种方式显然不行了。信号量机制在操作系统里面学习的比较熟悉了，信号量是一个整数计数器，其数值表示空闲临界资源的数量。当有进程释放资源时，信号量增加，表示可用资源数增加；当有进程申请到资源时，信号量减少，表示可用资源数减少。这个时候可以把锁机制认为是0-1信号量。关于信号量机制的函数。 int sem_init(sem_t * sem, int pshared, unsigned int value);初始化信号量 - 成功返回0，失败返回-1； - 参数sem：表示指向信号结构的指针。 - 参数pshared：不是0 的时候该信号量在进程间共享，否则只能在当前进程的所有线程间共享。 - 参数value：信号量的初始值。 int sem_wait(sem_t *sem); 信号量减一操作，有线程申请资源 - 成功返回0，否则返回-1 - 参数sem：指向一个信号量的指针 int sem_post(sem_t *sem);信号量加一操作，有线程释放资源 - 成功返回0，否则返回-1 - 参数sem：指向一个信号量指针 int sem_destroy(sem_t *sem); 销毁信号量。 - 成功返回0，否则返回-1 - 参数sem：指向一个信号量的指针。 参考实例四（生产者消费者）123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;pthread.h&gt;#include &lt;semaphore.h&gt;#define MAXSIZE 10int stack[MAXSIZE];int size =0;sem_t sem;void privide_data(void)&#123; int i; for(i =0;i&lt;MAXSIZE;++i) &#123; stack[i] = i; sem_post(&amp;sem); &#125;&#125;void handle_data(void)&#123; int i; while((i = size ++) &lt;MAXSIZE) &#123; sem_wait(&amp;sem); printf(\"cross : %d X %d = %d \\n\",stack[i],stack[i],stack[i] * stack[i]); sleep(1); &#125;&#125;int main()&#123; pthread_t privider,handler; sem_init(&amp;sem,0,0); pthread_create(&amp;privider,NULL,(void *)&amp;privide_data,NULL); pthread_create(&amp;handler,NULL,(void *)&amp;handle_data,NULL); pthread_join(privider,NULL); pthread_join(handler,NULL); sem_destroy(&amp;sem); return 0;&#125; 这段代码是经典的生产者消费者问题，只有当生产者把资源放入存储区，消费者才能取得。 参考文献 Linux多线程编程（不限Linux） Step by Step：Linux C多线程编程入门(基本API及多线程的同步与互斥)","tags":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/tags/Linux/"},{"name":"多线程","slug":"多线程","permalink":"http://yoursite.com/tags/多线程/"}]},{"title":"最长公共子序列实现","date":"2015-05-15T06:04:28.000Z","path":"2015/05/15/longest-common-subquence/","text":"@(C Plus Plus) 最长公共子序列前天看邹博关于最长公共子序列的问题，公式很好推导，但是实现起来没那么容易，我是用的最简单的方式，设置两个二维数组，一个用来记录子序列的长度，一个来记录方向。开始的时候把下标搞混了，结果总是不对，最后好不容易修改好了。全部的代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;void LCS(string str1,string str2,int **c,int **b)&#123; int len1 = str1.size(); int len2 = str2.size(); for(int i=0;i&lt;len1 +1;++i) &#123; c[0][i] = 0; b[0][i] = 0; &#125; for(int i =0;i&lt;len2+1;++i) &#123; c[i][0] = 0; b[i][0] = 0; &#125; for(int i=1;i&lt;len2+1;++i) &#123; for(int j =1;j&lt;len1+1;++j) &#123; if(str2[i-1] == str1[j-1]) &#123; c[i][j] = c[i-1][j-1] + 1; b[i][j] = 1; &#125; else &#123; if(c[i-1][j] &gt;= c[i][j-1]) &#123; c[i][j] = c[i-1][j]; b[i][j] = 2; &#125; else &#123; c[i][j] = c[i][j-1]; b[i][j] = 3; &#125; &#125; &#125; &#125;&#125;void getLCS(int **c,int **b,int i,int j,string str)&#123; if(i == 0 || j== 0) return; if(b[i][j] == 1) &#123; getLCS(c,b,i-1,j-1,str); cout&lt;&lt;str[i-1]&lt;&lt;\" \"; &#125; else if(b[i][j] == 2) &#123; getLCS(c,b,i-1,j,str); &#125; else &#123; getLCS(c,b,i,j-1,str); &#125;&#125;int main()&#123;// string str1(\"abcdcdab\");// string str2(\"badcdcba\"); string str1(\"bdcaba\"); string str2(\"abcbdab\"); int len1 = str1.size(); int len2 = str2.size(); int **c = new int *[len2 + 1]; for(int i=0;i&lt;len2+1;++i) c[i] = new int [len1 +1]; int **b = new int *[len2 +1 ]; for(int i=0;i&lt;len2 +1;++i) b[i] = new int[len1+1]; LCS(str1,str2,c,b); for(int i=0;i&lt;len2+1;++i) &#123; for(int j =0;j&lt;len1+1;++j) &#123; cout&lt;&lt;c[i][j]&lt;&lt;\" \"; &#125; cout&lt;&lt;endl; &#125; for(int i=0;i&lt;len2+1;++i) &#123; for(int j =0;j&lt;len1+1;++j) &#123; cout&lt;&lt;b[i][j]&lt;&lt;\" \"; &#125; cout&lt;&lt;endl; &#125; getLCS(c,b,len2,len1,str2); cout&lt;&lt;endl; return 0;&#125; 程序有很大的局限性，另外，我没想到如何解决多解的问题。最后求解LIS（最长递增子序列），把原序列排序后，用作保证递增的标准。然后求解两个序列的最长公共子序列，就可以求出最长递增子序列了。 现在还有的问题是： 避免使用方向数组b 多解问题。 参考十分钟搞定LCS","tags":[{"name":"LCS","slug":"LCS","permalink":"http://yoursite.com/tags/LCS/"},{"name":"最长公共子序列","slug":"最长公共子序列","permalink":"http://yoursite.com/tags/最长公共子序列/"}]},{"title":"C++ 动态创建二维数组","date":"2015-05-15T01:19:14.000Z","path":"2015/05/15/create-2-d-array/","text":"昨天看了July网站上邹博的关于LCS的视频，讲的比较清晰，昨天晚上想自己写代码实现以下，结果发现卡在了如何定义一个二维数组，这个二维数组的大小是根据字符串的大小定义的，这就需要如何在程序中动态的申请一个二维数组，最近脑子不太好使，容易犯浑，不知道怎么写了，上网查了，还有人认真的写过如果在程序中创建二维数组。以前写过一个迷宫游戏的程序，里面就是自己申请的二维数组，正好用上。 我在迷宫游戏中申请的二维数组数组名就是指针，二维数组就是二维指针，先从二维开始，申请一个指针数组，然后为每一个元素（元素就是指针）申请一个数组。代码如下：1234int **c; c = new int *[len1]; // 申请一个指针数组 for(int i =0;i&lt;len1;++i) // 为每一个指针再申请一个数组 c[i] = new int[len2]; 简单的测试一下：12345678910for(int i =0;i&lt;len1;++i) for(int j=0;j&lt;len2;++j) c[i][j] = str2[j]; for(int i =0;i&lt;len1;++i) &#123; for(int j = 0;j&lt;len2;++j) cout&lt;&lt;c[i][j]&lt;&lt;\" \"; cout&lt;&lt;endl; &#125; 释放空间呢？我是逐一删除的123for(int i=0;i&lt;len1;++i) delete []c[i]; delete []c; 一篇关于动态创建二维数组的文章如何在C/C++中动态分配二维数组 最后附上我的迷宫程序123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include \"time.h\"#define n1 20#define n2 20 typedef struct node&#123; int x; int y; int c;&#125;linkstack;linkstack top[400];int i,j,k, m=0;int a,b;//随机入口和出口int **maze;//定义二维指针存取迷宫char cmd;void init(int N1,int N2)//产生随机迷宫&#123; int i=0,j=0; maze=new int *[N1]; //申请长度等于行数加2的二级指针c for(i= 0;i&lt;N1;i++) //申请每个二维指针的空间 &#123; maze[i]=new int[N2]; &#125; srand((int)time(0)); for(i=1;i&lt;N1-1;i++) //随机输入迷宫的内容，0代表可通，1代表不通 for(j=1;j&lt;N2-1;j++) maze[i][j]=rand()%2; for(i=0;i&lt;N1;i++) maze[i][0]=maze[i][N1-1]=1; for(i=0;i&lt;N2;i++) maze[0][i]=maze[N2-1][i]=1; a=rand()%(N1-2)+1; //随机入口 b=rand()%(N2-2)+1; //随机出口 maze[a][0]=maze[a][1]=0; maze[b][N2-1]=maze[b][N2-2]=0; printf(\" the maze is:\\n\"); //输出迷宫0，1代码 for(i=0;i&lt;N1;i++) &#123; for(j=0;j&lt;N2;j++) printf(\"%d \",maze[i][j]); printf(\"\\n\"); &#125;&#125;int stackempty()&#123; if(i==0) return 1; else return 0;&#125;void push()&#123; i++;&#125;void printmaze(int N1,int N2) //打印迷宫&#123; printf(\" the maze is:\\n\"); for(i=0;i&lt;N1;i++) &#123; for(j=0;j&lt;N2;j++) printf(maze[i][j]?\"* \":\" \"); printf(\"\\n\"); &#125;&#125;void inittop(int N1,int N2) //初始化栈&#123; m=0; for(i=0;i&lt;N1*N2;i++) &#123; top[i].c =1; &#125; i=0; top[i].x=a; top[i].y=0; maze[a][0]=2;&#125;void interupt(int N1,int N2)&#123; inittop(N1,N2);//初始化top[]，之所有方向数为左 do &#123; if(top[i].c &lt;5) &#123; if(top[i].x==b &amp;&amp; top[i].y==N2-1) &#123; printf(\" The way %d is:\\n\",++m); for(j=0;j&lt;=i;j++) &#123; printf(\"(%d,%d)--&gt;\",top[j].x ,top[j].y ); &#125; printf(\"\\n\"); for(j=0;j&lt;N1;j++) &#123; for(k=0;k&lt;N2;k++) &#123; if(maze[j][k]==0) printf(\" \"); else if(maze[j][k]==2) printf(\"0 \"); else printf(\"* \"); &#125; printf(\"\\n\"); &#125; maze[top[i].x][top[i].y ]=0; top[i].c =1; i--; top[i].c +=1; continue; &#125; switch(top[i].c ) &#123; case 1: &#123; if(maze[top[i].x ][top[i].y+1]==0 &amp;&amp; top[i].y+1&lt;=N1) &#123; push(); top[i].x=top[i-1].x ; top[i].y=top[i-1].y+1; maze[top[i].x ][top[i].y]=2; &#125; else &#123; top[i].c+=1; &#125; break; &#125; case 2: &#123; if(maze[top[i].x-1][top[i].y] ==0 &amp;&amp; top[i].x -1&gt;=0) &#123; push(); top[i].x=top[i-1].x-1; top[i].y=top[i-1].y; maze[top[i].x][top[i].y]=2; &#125; else &#123; top[i].c +=1; &#125; break; &#125; case 3: &#123; if(maze[top[i].x ][top[i].y-1]==0 &amp;&amp; top[i].y -1&gt;=0) &#123; push(); top[i].x=top[i-1].x; top[i].y=top[i-1].y -1; maze[top[i].x][top[i].y ]=2; &#125; else &#123; top[i].c+=1; &#125; break; &#125; case 4: &#123; if(maze[top[i].x+1][top[i].y ]==0 &amp;&amp; top[i].x+1&lt;=N1) &#123; push(); top[i].x=top[i-1].x+1; top[i].y=top[i-1].y; maze[top[i].x][top[i].y]=2; &#125; else &#123; top[i].c +=1; &#125; break ; &#125; &#125; &#125; else &#123; if(stackempty()) &#123; if(m==0) printf(\"can not find one path\\n\"); break; &#125; else &#123; maze[top[i].x][top[i].y]=0; top[i].c =1; i--; top[i].c ++; &#125; &#125;&#125;while(1);&#125;int main()&#123; int t=0; int N1,N2; printf(\"Welcome play this game\\n\"); printf(\"please in put N(N&gt;2 &amp;&amp; N&lt;21):\\n\"); scanf(\"%d\",&amp;N1); fflush(stdin); while(N1&gt;20 ||N1&lt;3) &#123; fflush(stdin); printf(\" ERROR Number !!!!\\n \"); printf(\" please in put N again !!!\\n\"); scanf(\"%d\",&amp;N1); &#125; N2=N1; fflush(stdin); printf(\"##############################################################################\\n\"); printf(\"## createmaze:c ##\\n\"); printf(\"## printmaze :p ##\\n\"); printf(\"## mazepath :m ##\\n\"); printf(\"## quit :q ##\\n\"); printf(\"##############################################################################\\n\"); //cmd=getchar(); while((cmd=getchar())!=' ') &#123; if((cmd=='c') || (cmd=='C') || (cmd=='p') || (cmd=='P') || (cmd=='q') || (cmd=='Q') ||(cmd=='m')||(cmd=='M')) &#123; if(cmd=='c'|| cmd=='C') &#123; init(N1,N2);//初始化迷宫矩阵 t=1; &#125; else if(cmd=='p'|| cmd=='P') &#123; if(t) printmaze(N1,N2);//打印迷宫 else printf(\"please create maze ahead!\\n\"); &#125; else if(cmd=='m'|| cmd=='M') &#123; if(t) interupt(N1,N2);//解释执行迷宫出路 else printf(\"please create maze ahead!\\n\"); &#125; else if(cmd=='q'|| cmd=='Q') exit(0); &#125; else &#123; printf(\"ERROR input\\n\"); printf(\"please input again\\n\"); &#125; printf(\"##############################################################################\\n\"); printf(\"##############################################################################\\n\"); printf(\"## printmaze :p ##\\n\"); printf(\"## mazepath :m ##\\n\"); printf(\"## quit :q ##\\n\"); printf(\"##############################################################################\\n\"); fflush(stdin); &#125; free (maze); return 0;&#125; 参考July教育—邹博视频","tags":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"},{"name":"二维数组","slug":"二维数组","permalink":"http://yoursite.com/tags/二维数组/"},{"name":"数组指针","slug":"数组指针","permalink":"http://yoursite.com/tags/数组指针/"}]},{"title":"给博客换一个主题--yilia","date":"2015-05-14T13:24:10.000Z","path":"2015/05/14/change-a-new-theme-yilia/","text":"好久没有更新博客了，有很多东西都是记在了马克飞象，在Windows实在找不到更好用的MarkDown工具。暂时用这个先，虽然是收费的。原来的light感觉太过于简单了，总想换一个主题，昨天终于找到一个比较不错的yilia，比较符合我的口味。作者@Litten看上去是一个十足的文艺范，前端攻城狮，就职于鹅厂，师出华科，华科在我的印象中一直是一个特别有内涵的学校，我的本科的英文简写虽然与华科 的英文简写就差了一个字母，实际上却是差的很远，就算是现在研究生就读的学校，在我心中的地位也没有华科高。“可以去那里读个博”，这个 想法是糟糕透了，果断弃之，不死因为博士不好读，而是只想在华科读个本科生。 看了作者的不少的博文，越发感觉是一个十足的文艺范，比我们实验室的小伙伴略高一筹。看他的风格，我真想要不要学习一下前端的技术，是不是这样自己也能文艺一把。。。看了自己以前的文章，觉得自己顶多算是一个IT男。不过可以当作一个业余爱好，哄哄妹子。 其实这几天修改博客还是遇到了不少的问题，我对前端技术不熟，而且我当时学习前端的时候还没有NodeJs，很多地方都看不懂，只好屁颠屁颠的看人家的教程。 Litten的博客中有很多文章，都不错，有不少都是关于技术的，虽然我没怎么看懂，但是这文艺范的文章还是让我感觉很舒服。 @Litten非常热心，还在评论中给出自己的博客的备份，方便我们这种前端小菜鸡一招葫芦画瓢. 看了Owen Jia’s Blog的一篇文章，我知道怎么设置自己网站在浏览器上的图章了。 对了，还有几个图章制作工具 Web 2.0 Free Logo Generator faviconer 比特虫 目前博客访问是没有问题了，但是我的Fancybox不好用了，Litten把图像放在Instagram，无奈我的手机暂时不能访问，也就没法注册。暂时还是用七牛吧。 这就样吧，以后再写文章。 非常感谢 @Litten！","tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://yoursite.com/tags/Hexo/"},{"name":"yilia","slug":"yilia","permalink":"http://yoursite.com/tags/yilia/"},{"name":"主题","slug":"主题","permalink":"http://yoursite.com/tags/主题/"}]},{"title":"视觉跟踪资源整理（待更新）","date":"2015-05-11T11:53:54.000Z","path":"2015/05/11/tracking-resource/","text":"平时收集了一些关于自己的课题相关的网站书签，多数的时候忘了命名，或者命名又忘了，时间长了，就分不清哪一个了，不如写成博客，不定期更新，这样一目了然，没准还能帮到其他同僚。嗯，就这样，先整理一下。 最新更新时间 2015年3月27日 大人物 添加分类时间：2015年3月27日 修改分类时间：2015年3月27日 Babenko — UCSD 雷 震 — CASIA Xiaofei He — 浙大 斯坦福视觉实验室 Ming-Hsuan Yang 卢湖川 — 大连理工 Haibin Ling Naiyan Wang Shai Avidan 蔡登 汪凌峰 — 中国科学院自动化研究所 , 助理研究员 Dorin Comaniciu 徐新兴 Vishal m.patel Ignacio Ramirez 贾佳亚 Fan Yang Honglak Lee Andrew Ng Lei Zhang Michael Elad Ma Yi Chunming Li — Level Set Daniel Cremers — Level Set Tim Cootes — Level Set Graph Cuts Home Page Ce Liu Naiyang Guan — Matrix Factorization Deqing Sun — Optical Flow 数据集 添加分类时间： 2015年3月27日 修改分类时间： 2015年3月27日 Tracking dataset BoBoT - Bonn Benchmark on Tracking Computer Vision Datasets A single-object video tracking dataset CVonline: Image Databases 杨博 代码类 添加分类时间：2015年3月27日 修改分类时间：2015年3月27日 其他类 添加分类时间：2015年3月27日 修改分类时间：2015年3月27日","tags":[{"name":"tracking","slug":"tracking","permalink":"http://yoursite.com/tags/tracking/"}]},{"title":"LeetCode 009 Palindrome Number 解题报告","date":"2015-04-11T02:41:15.000Z","path":"2015/04/11/leetcode009-solution/","text":"题目描述：给定一个整数，求这个整数的回文数，但是有有一个要求：不能使用额外的空间，也就是想用字符串的方式处理是不可能了。不仅如此，还有其他条件，比如反转后悔溢出，负数等等。要是对回文数不熟悉，先看看百度百科 英文描述Determine whether an integer is a palindrome. Do this without extra space. 一些暗示Some hints:Could negative integers be palindromes? (ie, -1) If you are thinking of converting the integer to string, note the restriction of using extra space. You could also try reversing an integer. However, if you have solved the problem “Reverse Integer”, you know that the reversed integer might overflow. How would you handle such case? There is a more generic way of solving this problem. 我的代码这次我的代码不怎么好，效率一般，运行时间是129ms123456789101112131415161718192021222324252627bool Solution009::isPalindrome(int x)&#123; if(x &lt; 0) return false; int high = 1; int low = 10,clow = 1; int t =x; while(t/10) &#123; t /=10; high *= 10; &#125; while(high/10) &#123; int h = (x / high)%10; int l = (x % low)/clow; if( h==l) &#123; clow *= 10; low *= 10; high /= 10; &#125; else return false; &#125; return true;&#125; 解题思路我的解题思路很简单，就是设置两个指针，分别从前往后和从后往前遍历，但是这里不是字符串，指针就不合适了，我就是从高位向地位取数，和从地位向高位取数，然后做比较。这里看似比较简单，其实在取高位数的时候容易产生溢出，所以一定要小心。 参考百度百科","tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://yoursite.com/tags/LeetCode/"},{"name":"Math","slug":"Math","permalink":"http://yoursite.com/tags/Math/"}]},{"title":"LeetCode 008 String to Integer (atoi) 解题报告","date":"2015-04-10T13:12:41.000Z","path":"2015/04/10/leetcode008-solution/","text":"题目描述：实现标准库函数atoi，要解决空格字符问题，正负号问题，以及字母，溢出等问题，函数接收参数是string类型，返回值是int类型 英文描述Implement atoi to convert a string to an integer. Hint: Carefully consider all possible input cases. If you want a challenge, please do not see below and ask yourself what are the possible input cases. Notes: It is intended for this problem to be specified vaguely (ie, no given input specs). You are responsible to gather all the input requirements up front. 这个题目在2015年2月10号修改过The signature of the C++ function had been updated. If you still see your function signature accepts a const char * argument, please click the reload button to reset your code definition. 下面是一些提示Requirements for atoi:The function first discards as many whitespace characters as necessary until the first non-whitespace character is found. Then, starting from this character, takes an optional initial plus or minus sign followed by as many numerical digits as possible, and interprets them as a numerical value. The string can contain additional characters after those that form the integral number, which are ignored and have no effect on the behavior of this function. If the first sequence of non-whitespace characters in str is not a valid integral number, or if no such sequence exists because either str is empty or it contains only whitespace characters, no conversion is performed. If no valid conversion could be performed, a zero value is returned. If the correct value is out of the range of representable values, INT_MAX (2147483647) or INT_MIN (-2147483648) is returned. 我的程序还是老样子，废话少数，先贴上代码1234567891011121314151617181920212223242526272829303132333435363738394041int Solution008::atoi(string str)&#123; const int max = 2147483647; const int min = -2147483648; bool positive = true; int len = str.length(); double result = 0; int idx; for(idx = 0;idx&lt;len;++idx) &#123; if(str[idx] == ' ') continue; else break; &#125; if(str[idx] == '-' &amp;&amp; idx &lt; len) &#123; positive = false; idx ++; &#125; else if(str[idx] == '+' &amp;&amp; idx &lt; len) &#123; idx ++; &#125; if(str[idx] &lt; '0' || str[idx] &gt; '9' || idx &gt;= len) return 0; for(;idx &lt;len;++idx) &#123; if(str[idx] &gt;= '0' &amp;&amp; str[idx] &lt;= '9') &#123; result = result * 10 + (str[idx] - '0'); if(positive &amp;&amp; result &gt; max) return max; else if(!positive &amp;&amp; (-1 * result) &lt; min ) return min; &#125; else break; &#125; return (positive ? result :(-1 * result));&#125; 解题思路这道题目并不是很难，而且分类标准也是Easy，但是AC的比例比较低，开始的时候还真被这数字吓到了。题目是不难，需要考虑多种情况。分为以下几个步骤： 首先去除字符串前缀空格； 然后判断有无正负号，若有正负号，设置正负号标志，指针后移一位，否则，不做处理； 判断第一个字符是否是数字，若不是，说明是无效数字，返回为0 ；否则正常处理；这个过程指针不移动； 循环处理后面的字符；若是数字字符，正常处理，并判断是否越界；若不是数字字符，退出循环，返回数字 参考无","tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://yoursite.com/tags/LeetCode/"},{"name":"Math","slug":"Math","permalink":"http://yoursite.com/tags/Math/"}]},{"title":"开始学习 Python Scikit Learn","date":"2015-04-10T05:43:23.000Z","path":"2015/04/10/start-python-sklearn/","text":"昨天参加参加了网易有道在清华大学的技术沙龙，准确的说是瞅了一会儿，因为人实在是太多了，没办法挤进去，幸运的是工作人员在走廊里收了我们的简历。幸好个子高点（周围一大堆妹子），看了几眼PPT，讲的都是机器学习相关的东西，看来机器学习已经在工业应用很好了，作为准备求职的研究僧，有必要准备一下Machine Learning的储备知识。 目前我知道的提供Machine Learning学习的库，除了OpenCV，还有一个被称作是SKLearn的Python工具包。OpenCV的入门知识我已经学了，其中Machine Learning模块还需要学习一下，但是现在时间比较紧张，先把这个SKLearn的工具包学习一下，也顺便复习一下Python，毕竟好多公司还是要有有Python技能。 今天的时间还是有限，下午还要写写开题 报告相关的东西，所以这个东西要持续更新一段时间，也许到周末就可以。 简介我也是刚刚接触这个东西，简介部分也是根据我当前的理解。详细的介绍请移步维基百科和推库等等吧，有很多相关的资料。Google一搜就很多。 安装安装也有很多种方式，SKLearn只是Python的一个开发包，需要一些依赖库，学习Python我也只是入门级别，很多东西还是要慢慢的学习整理。 下面列举几篇文章，介绍Python 安装与使用：CSDN的一篇文章Windows 下 Python easy_install 的安装 windows下安装scikit learn以及python的各种包 百度贴吧的一篇文章 安装PyCharmInstalling the SciPy StackScikit Learn 主页 简单使用","tags":[{"name":"Machine Learning","slug":"Machine-Learning","permalink":"http://yoursite.com/tags/Machine-Learning/"},{"name":"Python","slug":"Python","permalink":"http://yoursite.com/tags/Python/"},{"name":"Scikit Learn","slug":"Scikit-Learn","permalink":"http://yoursite.com/tags/Scikit-Learn/"}]},{"title":"LeetCode 006 ZigZag Conversion 解题报告","date":"2015-04-09T14:07:55.000Z","path":"2015/04/09/leetcode006-solution/","text":"问题描述：给定一个字符串，用Zigzag Pattern模式书写，具体什么是Zigzag Pattern参考维基百科就是按照Z形状写的，现在要求按照正常的顺序读出来。下面是英文题目描述。The string “PAYPALISHIRING“ is written in a zigzag pattern on a given number of rows like this: (you may want to display this pattern in a fixed font for better legibility)格式如下:123P A H NA P L S I I GY I R 要求输出正常的顺序：”PAHNAPLSIIGYIR“ 还是老规矩，不想听我废话解释，就直接看代码：123456789101112131415161718192021222324252627282930313233343536string Solution006::convert(string s, int nRows)&#123; if(nRows &lt; 2) return s; string result = \"\"; for(int row = 0;row &lt; nRows; ++ row) &#123; if(row == 0|| row == nRows -1) &#123; int step = nRows + nRows - 2; int i=row; while(i &lt; s.length()) &#123; result += s[i]; i += step; &#125; &#125; else &#123; int i = row; int midstepodd = (nRows - 1 - row) * 2; int midstepeven = row * 2; int col = 1; while(i &lt; s.length()) &#123; result += s[i]; if(col &amp; 0x1) i += midstepodd; else i += midstepeven; col ++; &#125; &#125; &#125; return result;&#125; 唠叨一下这种字符排血很容易可以找到规律，找到字符下标的v，逐行读取字符就可以了。分两种情况： 第一行和最后一行，这两行比较好判断，因为相邻的两垂直列之间没有斜着排列的字符，所以，相邻两垂直列之间的字符是固定的，而且比较容易计算出来：step = nRows + nRows - 2； 中间行，比较讨厌的是中间行相邻的列之间有一个斜着排列的字符，其实，没有去除斜着排列的一列，中间行两垂直列之间的间隔也是固定的，而且跟第一种情况一样，但是既然有了中间这个斜着排列的一列，相当于两个垂直之间添加了一个字符，这个字符的下标也有规律，这个字符的下标将第一种情况的Step分成了两部分，其中前一部分是midstepodd = (nRows - 1 - row) * 2，后一部分是midstepeven = row * 2，两部分在相邻两垂直列之间是交替的，且它们的和是第一种情况的Step。 根据行号分为两种情况，写代码也就轻松了，运行时间也算是比较可以了，26ms。 参考CSDN博客","tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://yoursite.com/tags/LeetCode/"},{"name":"Math","slug":"Math","permalink":"http://yoursite.com/tags/Math/"}]},{"title":"LeetCode 007 Reverse Integer 解题报告","date":"2015-04-09T03:40:33.000Z","path":"2015/04/09/leetcode007-solution/","text":"题目描述：将一个整型的数字逆转，下面是英文描述 Reverse digits of an integer. Example1: x = 123, return 321 Example2: x = -123, return -321 TIPs：Have you thought about this?Here are some good questions to ask before coding. Bonus points for you if you have already thought through this! If the integer’s last digit is 0, what should the output be? ie, cases such as 10, 100. Did you notice that the reversed integer might overflow? Assume the input is a 32-bit integer, then the reverse of 1000000003 overflows. How should you handle such cases? For the purpose of this problem, assume that your function returns 0 when the reversed integer overflows. Update (2014-11-10): Test cases had been added to test the overflow behavior.解题思路如果你不愿意听我废话，那就先看代码：123456789101112131415161718int solution007::reverse(int x)&#123; const int max = 2147483647; const int min = -2147483648; double result = 0; while(x) &#123; if(x &gt; 0 &amp;&amp; (result *unsigned(10)) &gt; (max)) return 0; if(x &lt; 0 &amp;&amp; (result *unsigned(10)) &lt; (min)) return 0; result = result * 10 + x % 10; x /= 10; &#125; return int(result);&#125; 我以前做过清华的ACM训练题，其中有不少都是关于大数计算的，比如求解2000的阶乘，这个问题当时用了一个下午才做出来，而且是用的交容易的方法，用数组来模拟计算过程，所以遇到这个数学模拟题，我的第一想法就是用数组模拟大数，再仔细一看，多虑了，于是顺手写下了下面的代码。12345678910int solution007::reverse(int x)&#123; int result = 0; while(x) &#123; result = result * 10 + x % 10; x /= 10; &#125; return result;&#125; 结果自然是不能通过的，换做是在2012年，这个方法是可以通过这个测试用例的，在TIPs发现，这个题目在201年被修改过，需要考虑整数反转溢出的情况。我尝试了各种方法来解决溢出问题，其中最直接的思想就是用一个取值范围更大的类型，来临时存储结果，若这个临时结果在×10后发生越界（大于整型的最大范围，或小于整型的最小值），就返回0（题目要求，在发生溢出的时候返回0）。我的第一次尝试是用unsigned int，无论如何都不能成功。因为unsigned int所能表达的最大值只不过是int类型的两倍。long类型是在介绍的时候虽然是比int类型的范围更大，但是在《C++ Primer 第四版》31页有这样的一句话通常在32位机器中int类型的字长与long类型的字长相同，long类型也不行。最后只能用double类型了。于是有了我上面的代码。 int类型的数字到底有多大我也记不住到底有多大，用程序输出一下就知道了：1234int t = 0x7fffffff;int tt = 0x80000000;cout&lt;&lt;int(t)&lt;&lt;endl;cout&lt;&lt;int(tt)&lt;&lt;endl; 参考C++如何取得int型的最大最小值","tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://yoursite.com/tags/LeetCode/"},{"name":"Math","slug":"Math","permalink":"http://yoursite.com/tags/Math/"}]},{"title":"Windows8.1 安装OpenSSH","date":"2015-04-03T12:36:15.000Z","path":"2015/04/03/openssh-for-windows/","text":"最近要在实验室干活，实验室的电脑是Ubuntu系统，OpenSSH可以在实验室其他机器之间很方便的传输文件，有些工作还在Windows下继续，所以就在自己的Windows系统上安装OpenSSH。Windows的毛病还真不少，不过也有不少人开发了Windows版本的OpenSSH，详细的OpenSSH For WIndows的介绍点击，下面简单的说说如何在Windows上使用OpenSSH。 我的基本配置 Windows 8.1 中文版 Ubuntu 12.04 LTS 实验室局域网 在windows下使用 OpenSSH与Ubuntu 传输文件 Putty安装及简介Putty是网络连接工具，包含了OpenSSH的功能，在Windows下算是比较好用的OpenSSH工具，详细的介绍在百度百科和维基百科都有很详细的介绍，我就不多嘴了。 官方下载链接 Putty中文教程链接 算了不说了本来要写一个详细的教程，自己的配置过程，突然发现上面的Putty中文教程很详细了，就不罗嗦了。 参考 在windows下使用OpenSSH 百度百科 维基百科 如何使用Putty远程(SSH)管理Linux VPS OpenSSH Windows Putty中文教程 官方网址","tags":[{"name":"Windows8.1","slug":"Windows8-1","permalink":"http://yoursite.com/tags/Windows8-1/"},{"name":"opensh","slug":"opensh","permalink":"http://yoursite.com/tags/opensh/"},{"name":"putty","slug":"putty","permalink":"http://yoursite.com/tags/putty/"}]},{"title":"Python批量重命名文件","date":"2015-03-27T11:27:19.000Z","path":"2015/03/27/find-job-python-1/","text":"前一阵做实验的时候，需要修改大量的数据文件，以前简单的学习过Python，这次好好利用起来，利用这种轻便的脚本语言批量文件，记录在自己的博客，方便以后学习。 格式化文件名下载的数据文件名字的格式：image_000001.jpg但是在程序中读取文件的时候需要给文件名排序，不晓得Matlab是怎么排序的，反正这样的文件格式造成文件读入的顺序乱，我想重新命名文件去掉文件名的前缀，修改后的文件名格式：1.jpg下面是我写的代码： 1234567891011121314151617181920212223242526#!/usr/bin/env python # 要想在Linux的Shell中直接运行，或者在Windows下双击运行，就在文件前面添加这个import os # 引入 os 库def rename(): # 定义函数 path = raw_input(\"Please input the path name \") # 提示输入路径名 print path # 打印路径名，测试用的，可以去掉 forMat = raw_input(\"Please input the extention \") # 提示输入文件格式，这里我输入的是 .jpg print forMat # 打印文件格式，测试用的，可以去除 for(path,dirs,files) in os.walk(path): # 读取文件 for filename in files: # 循环读取每个文件名 ext = os.path.splitext(filename)[1] # 分离文件扩展名 name = os.path.splitext(filename)[0] # 分离文件名 if(ext == forMat): # 判断文件扩展名与属于扩展名是否一致 print filename # 打印文件全名，测试用 print name # 打印文件名，测试用 #name_part = name.replace(\"frame_\",\"\") # 去掉文件名前缀引文，这里注释掉了 newname = str(int(name)) + forMat # 将 00001 转换成 1 ，并重新构建新的文件名 oldpath = path + \"//\" + filename # 原文件路径 newpath = path + \"//\" + newname # 新文件路径 try: os.rename(oldpath,newpath) # 重命名 except BaseException, e: print(str(e)) print newpath # 输出新文件全名，测试用if __name__ == '__main__': # 主函数中调用自定义函数 rename() 带命令行参数的批量重命名上面的程序，可以在终端直接运行，在提示的帮助下输入文件路径和文件扩展名，下面我改进一下，可以像带有参数的命令一样使用。 代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#!/usr/bin/env python # 要想在Linux的Shell中直接运行，或者在Windows下双击运行，就在文件前面添加这个import os # 引入 os 库import sys # 引入 sys 库if len(sys.argv) == 1: # 判断若只输入命令，则提示使用方法 print \"Usage: ./renmDS pathname forMat\" # 一下都是在打印使用说明，略粗糙 print \"before rename:\" print \"--pathname\" print \"--+ oldfilename-1.fotMat\" print \"--+ oldfilename-2.fotMat\" print \" ...... \" print \"--+ oldfilename-n.fotMat\" print \"after rename:\" print \"--pathname\" print \"--+ 00001.format\" print \"--+ 00002.format\" print \" ...... \" print \"--+ 0000n.format\" print \" \" print \"Note: Default forMat = ppm\" print \" \" sys.exit()if len(sys.argv) == 2: # 若没有输入扩展名，则默认格式是 .ppm forMat = \".ppm\"else: forMat = \".\" + sys.argv[2]pathname = sys.argv[1] # 第一个参数是命令，第二个参数文件路径，第三个参数是扩展名reguStr = '%05d' # 格式化文件名正则表达式def rename(): # 以下部分基本与上面相同 for(path,dirs,files) in os.walk(pathname): idx = 0 for filename in files: name = os.path.splitext(filename)[0] ext = os.path.splitext(filename)[1] if(ext == forMat): #newname = filename.replace(\" \",\"_\") #idx = idx + 1 idx = int(name) #numIdx = reguStr%idx # 用正则表达式格式化文件名 从1.jpg到00001.jpg格式 #print numIdx #newname = str(numIdx) newname = str(idx) print idx newname = newname + forMat oldpath = path + \"//\" + filename newpath = path + \"//\" + newname try: os.rename(oldpath,newpath) except BaseException, e: print(str(e)) print newpathif __name__ == '__main__': rename() 结束","tags":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/tags/Python/"}]},{"title":"在博客中插入图像","date":"2015-03-24T07:01:47.000Z","path":"2015/03/24/insert-image-in-blog/","text":"这几天看论文，总是找不到，磁盘文件组织已经可以了，可是还是文件太多，还有要和实验室的一台Linux平台的机器同步，每次大量的数据同步是很麻烦的，文件零碎，导致磁盘速度越来越慢，突然想起前几天注册的七牛云存储，于是想起来把文章都同步在Web，其他数据压缩后也同步在上面，时间有限，先做一个Reading，用七牛做图床，原理应该是一样的。下面参考简书上面的文章，简单的用七牛做云存储。 参考文献 简书—推荐一个稳定而强大的图床","tags":[{"name":"image","slug":"image","permalink":"http://yoursite.com/tags/image/"},{"name":"七牛","slug":"七牛","permalink":"http://yoursite.com/tags/七牛/"},{"name":"图床","slug":"图床","permalink":"http://yoursite.com/tags/图床/"}]},{"title":"数据库原理复习系列（一）","date":"2015-03-16T00:37:29.000Z","path":"2015/03/16/2015-03-16-database/","text":"要找工作找实习了，看了看之前的项目，几乎都是与数据库应用相关的，虽然项目比较水，但是面试的时候估计人家得详细的问。所以，数据库这块得非常认真的准备。准备看几篇文章，看看书，今天是第一天复习，先把基础的东西搞懂。 No.1 一些名词概念 数据库（database）：存储和提供数据的东西（库房）； 数据（data）：数据库中存储的基本对象； 数据库管理系统（DBMS）：属于与系统软件，是介于用户与操作系统的数据库管理软件； 数据库系统（DBS）：包括数据库、数据库管理系统、应用系统和数据库管理员（DBA）； 主键（Primary Key）：用于唯一的标识表中某一条记录的属性或者属性的集合； 外键（Foreign Key）：用于与另外一张表关联，是另外一张表的主键； 超键（Super Key）：官方的解释是唯一能标识元组的一个属性或者是多个属性的集合，其实就是主键，或者其他属性与主键的集合； 元组（Tuple）：在二维表中，元组是一行数据，在二维关系数据库中，也被称作是记录； 候选键（）：没有多余属性的超键，主键其实就是候选键中的唯一一个； 模式（Schema）：一个数据库的描述，包括对数据库结构，数据类型和约束； 实例（Instance/State）：数据库中某一刻真实存在的数据。Instance是Schema在某一时刻的具体化，实例化； 数据库操纵语言（DML：Database Manipulation Language）：增删改查； 数据库定义余元（DDL：Data Definition Language）：定义、修改、删除数据库中的对象； 数据库控制余元（DCL：Database Control Lang）：用于控制用户对数据库的操纵权限； 数据模型（Data Model）：现实世界数据的抽象，用来定义数据如何组织，数据之间的关系怎样； 并相容性（Union Compatibility）：两个关系具有并相容性需要保证两个关系的属性个数和每个属性的域是相同的； 视图（View）：视图是虚拟的表，并不是物理上真实存在的表，是由基本表和其他视图派生的数据，对视图的更新实际上转换为对基表的更新； No.2 数据模型（Data Model）分层理解数据模型，共分为三层。 概念模型（Conceptual）：从用户的角度来对数据和信息建模； 逻辑模型/实现模型（Logical/Implementation）：层次模型、网状模型、关系模型 物理模型（Physical）：数据在DBMS产品中的物理存储No.3 数据库系统的三级模式（three-level schema） 内模式（internal schema）：也称作存储模式，数据的屋里结构和存储方式的描述，是数据在数据库内部的表示方式。 概念模式（Conceptual Schema）：也称作全局模式，有时候简称模式，是对数据库中全体数据的逻辑结构和特征的描述 外模式（External Schema）：也称作子模式或者用户模式，数据库用户能够看到和使用的局部数据的逻辑结构和特征的描述。No.4 数据库系统的两级映射以及物理和逻辑独立性： 两级映射： 模式/内模式映射 模式/外模式映射 数据的物理独立性— 模式/内模式映射提供了数据的物理独立性，当数据的物理结构发生变化时，只需要修改内模式与概念模式之间的映射即可 数据的逻辑独立性— 概念模式与外模式之间的映射提供了数据的逻辑独立性。当数据的整体逻辑结构发生变化时，只需要修改各个外模式与概念模式之间的映射即可保证应用程序不受影响 No.5 数据的约束条件—完整性约束 域约束：对属性取值的约束 键约束：每个关系必须要有主键，且每个主键不能相同 非空约束：属性值不能为NULL 实体完整性约束：主键值不能为NULL 参照完整性约束：外键值可以为NULL，但是当其值不为空时，被参照的关系的主键值必须与参照关系的外键值相同 用户定义完整性：它主要是针对关系的主关键字和外部关键字取值必须有效而做出的约束。用户定义完整性(user defined integrity)则是根据应用环境的要求和实际的需要，对某一具体应用所涉及的数据提出约束性条件。这一约束机制一般不应由应用程序提供，而应有由关系模型提供定义并检验，用户定义完整性主要包括字段有效性约束和记录有效性。 No.6 数据操作可能引起违反约束 插入操作：域约束、键约束、非空约束、实体完整性约束、参照完整性约束； 删除操作：参照完整性约束； 更新操作：域约束、键约束、非空约束、实体完整性约束、参照完整性约束； No.7 结构化查询语句（SQL）的执行顺序 From子句组装来自不同数据源的数据； WHERE子句基于指定的条件对记录筛选； GROUP BY子句将数据划分多个组； 使用内聚函数进行计算； HAVING子句筛选分组； 计算所有的表达式； ORDER BY对结果集进行排序 NO.8 控制冗余（Controled Redundancy）与非控制冗余（Uncontroled Redundancy）的区别为控制冗余的数据存储冗余会导致如下问题： 更新数据时的重复工作； 浪费空间； 数据可能不一致理想情况下，我们应该设计一个没有冗余的数据库，但是有时候为了提高查询效率我们引入了控制冗余（Controlled Redundancy）数据库。 No.9 关系是个什么东西？ 关系看上去像一张二维表； 关系的域（属性值的取值范围）为一组原子值（不可再分割的值）； 关系中的元组必定各不相同； No.10 关系代数 并 差 笛卡儿积 选择 投影 No.11 内连接的种类 等值连接 不等连接 自然连接 No.12 SQL 语句No.13 三值为此逻辑 TRUE FAlSE UNKNOWN No.14 数据库应用系统设计的基本过程 需求收集和分析（Requirements Collections and Analysis） 概念结构设计（Conceptual Database Design） 选择合适的DBMS（Choice of a DBMS） 逻辑结构设计（Data Model Mapping (Logical Database Design)） 物理结构的设计（Physical Database Design） 数据库实施（Database System Implementation） 数据库运行和维护（Database System Operation and Maintenance） No.15 将ER模型映射成逻辑模型的步骤 映射强实体型 映射弱实体型 映射1：1二元联系型 映射1：N二元联系型 映射N：N二元联系型 映射多值属性 映射N元联系 No.16 数据库范式 一范式：且仅当所有域只包含原子值，即每个分量都是不可再分的数据项，则称实体E满足第一范式 二范式：当且仅当实体E满足第一范式，且每一个非键属性完全依赖主键时，满足第二范式 三范式：当且仅当实体E是第二范式（2NF），且E中没有非主属性传递依赖时，满足第三范式 未完待续！","tags":[{"name":"数据库概念","slug":"数据库概念","permalink":"http://yoursite.com/tags/数据库概念/"}]},{"title":"2015-03-15 read airticle from weibo","date":"2015-03-15T08:40:28.000Z","path":"2015/03/15/2015-03-15-read-airticle-from-weibo/","text":"以前在微博上面分享了很多有意思的文章，但是大多数都是扫一眼，大题的看一下，有的仔细看了，但是没有总结，没有形成自己的知识，自己搭建了这个小博客，可以把看文章的心得放在上面，可供分享，另一方面也是方面自己回忆学习。今天打算阅读三篇文章，分别是奇异值分解SVD、26条时间管理技巧和Github使用系列文章，其中Github使用系列文章是一个系列的文章，今天是不太可能看完了，所以只能持续几天。","tags":[{"name":"Github","slug":"Github","permalink":"http://yoursite.com/tags/Github/"},{"name":"SVD","slug":"SVD","permalink":"http://yoursite.com/tags/SVD/"},{"name":"时间管理","slug":"时间管理","permalink":"http://yoursite.com/tags/时间管理/"}]},{"title":"丰富我的Hexo博客","date":"2015-03-13T07:57:14.000Z","path":"2015/03/13/enrich-my-blog/","text":"经过半个下午的努力，终于把自己的小站搭建好，并放在自己的Github上面，上午写了几篇文章，下午刚开完会，准备再弄一会自己的小站，丰富一下主题。就在刚才，我修改了一个小地方，准备部署的时候，突然不能推送。。。估计应该是Github水土不服。不管了，以后托管Gitcafe上，现在时间紧，就这样吧，下面说说我是怎样丰富我的小站的。","tags":[{"name":"分类","slug":"分类","permalink":"http://yoursite.com/tags/分类/"},{"name":"挂件","slug":"挂件","permalink":"http://yoursite.com/tags/挂件/"},{"name":"标签云","slug":"标签云","permalink":"http://yoursite.com/tags/标签云/"}]},{"title":"在我的新博客上安装多说评论框","date":"2015-03-13T02:37:16.000Z","path":"2015/03/13/how-add-duoshuo-comment/","text":"我的这个小网站主要是用来写博客，分享一些工作和学习的经验，记录一下比较有意义的事情，吐槽一下生活，当然也会有好友来多说几嘴，那就需要一个评论框，网友都说这个主题自带的评论框不太好用，国内的多说比较火，那就用这个咯。惯用语多说，不了解的童鞋可以自己了解一下。","tags":[{"name":"多说","slug":"多说","permalink":"http://yoursite.com/tags/多说/"},{"name":"百度分享","slug":"百度分享","permalink":"http://yoursite.com/tags/百度分享/"}]},{"title":"我是这样搭建Hexo博客的","date":"2015-03-12T14:17:11.000Z","path":"2015/03/12/how-to-make-hexo-blog/","text":"刚刚用自己在Ubuntu14.04系统上安装Qt4.8.6的过程试着写了一份Blog，看着还像那么回事，已经好久没有使用MarkDown标记语言了，语法还有点生疏了，没关系最近就用这个写Blog了，应该很快就熟悉了。下面记录我是如何配置Hexo的，我只是介绍步骤，至于详细的信息，可以参考简书上的一篇文章","tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://yoursite.com/tags/Hexo/"}]},{"title":"Ubuntu14.04编译安装Qt4.8.6","date":"2015-03-12T13:44:09.000Z","path":"2015/03/12/the-first-blog-in-hexo/","text":"今天下午使用Hexo搭了一个小站，以前的文章都写在CSDN和新浪博客，到处都是广告，于是就搭建了这个属于自己的网站，自己随意搭配，以后慢慢将重要的文章转移到自己的小站。第一篇文章就写写如何在Ubuntu14.04上编译安装Qt4.8.6； Step1 安装依赖库：1sudo apt-get install libfontconfig1-dev libfreetype6-dev libx11-dev libxcursor-dev libxext-dev libxfixes-dev libxft-dev libxi-dev libxrandr-dev libxrender-dev Step2 在Qt的官网下载Qt4.8.6的源码：1wget http://download.qt.io/archive/qt/4.8/4.8.6/qt-everywhere-opensource-src-4.8.6.tar.gz Step3 解压包12gunzip qt-everywhere-opensource-src-4.8.6.tar.gz # uncompress the archive tar xvf qt-everywhere-opensource-src-4.8.6.tar # unpack it Step4 生成Makefile文件1./configure Step5 构建1make Step6 安装1make install Step7 配置环境变量12PATH=/usr/local/Trolltech/Qt-4.8.6/bin:$PATH export PATH Step8 创建软连接1sudo ln -s /usr/local/Trolltech/Qt-4.8.6/bin/qmake /usr/lib/i386-linux-gnu/qt4/bin/qmake 参考链接： 官网文档","tags":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/tags/Linux/"},{"name":"Qt4","slug":"Qt4","permalink":"http://yoursite.com/tags/Qt4/"},{"name":"Ubuntu","slug":"Ubuntu","permalink":"http://yoursite.com/tags/Ubuntu/"}]}]